
### Forward Search

Forward search is a simple and intuitive planning algorithm. It starts with the initial state and generates successor states by applying available actions. If a successor state is a goal state, the planning process terminates. Otherwise, the algorithm continues the search from the successor state.

### Backward Search

Backward search is a planning algorithm that starts with the goal state and works backward to the initial state. It generates predecessor states by applying available actions and checks if the predecessor state is the initial state. If it is, the planning process terminates. Otherwise, the algorithm continues the search from the predecessor state.

### Heuristic Search

Heuristic search algorithms, such as A* and IDA*, use heuristic functions to guide the search process. The heuristic function estimates the cost of reaching a goal state from a given state. The search algorithm then chooses the state with the lowest estimated cost and expands it.

### Graphplan

Graphplan is a classical planning algorithm that uses a propositional logic representation of the planning problem. It constructs a planning graph that represents the set of all possible states and actions in the planning problem. The planning graph is then used to find a valid plan.

### STRIPS

STRIPS (Stanford Research Institute Problem Solver) is a language and planning system for describing and solving problems in artificial intelligence. It was developed at SRI International in the 1960s and was one of the first automated planning systems.

The STRIPS language consists of a set of <mark style="background: #BBFABBA6;">states, actions, and initial and goal states</mark>. The actions describe how the states can be changed, and the initial and goal states describe the starting and ending points of the problem. The actions are specified in terms of preconditions, which must be true for the action to be performed, and effects, which describe the changes that occur to the states when the action is performed.

STRIPS uses a forward-chaining inference algorithm to search for a plan that will take the system from the initial state to the goal state. The algorithm builds a search tree of possible plans, starting with the initial state and working forward through the actions until it reaches the goal state.

#### Example

Initial state: At(Robot, SFO) ∧ At(Cargo, SFO) ∧ CargoWeight(Cargo, Heavy)

Goal state: At(Robot, JFK)

Actions:
- Drive(From, To)
    Preconditions: At(Robot, From) ∧ Connected(From, To)
    Effects: ¬At(Robot, From) ∧ At(Robot, To)
- Load(Cargo, Plane)
    Preconditions: At(Robot, Airport) ∧ At(Cargo, Airport) ∧ CargoWeight(Cargo, Light) ∧ PlaneCapacity(Plane, Available)
    Effects: ¬At(Cargo, Airport) ∧ In(Cargo, Plane)
- Unload(Cargo, Plane)
    Preconditions: At(Robot, Airport) ∧ In(Cargo, Plane)
    Effects: ¬In(Cargo, Plane) ∧ At(Cargo, Airport)

### PDDL

PDDL stands for "Planning Domain Definition Language". It is<mark style="background: #ABF7F7A6;"> a formal language used to describe planning problems and domains in artificial intelligence</mark>. PDDL was created to standardize the representation of planning problems and solutions, making it easier to share and compare different planning algorithms.

PDDL is a declarative language, meaning that it describes the problem in terms of its <mark style="background: #FF5582A6;">properties and constraints</mark>, rather than specifying a set of steps to solve the problem. The language provides a way to define the initial state of a problem, the set of possible actions, and the goal state.

PDDL is commonly used in AI research and development, and many planning systems and solvers are designed to work with PDDL. The language has evolved over time, with new versions adding additional features and capabilities to better represent more complex planning problems.

#### Syntax

The syntax of PDDL consists of a set of rules that define the elements of the planning problem, such as the objects, initial state, goal state, and actions. Here is a brief overview of the syntax:

-   Objects: declared using the `:objects` keyword followed by a list of object names enclosed in parentheses.
    
-   Predicates: declared using the `:predicates` keyword followed by a list of predicate names and their arguments enclosed in parentheses.
    
-   Initial state: declared using the `:init` keyword followed by a list of ground literals that describe the initial state of the planning problem.
    
-   Goal state: declared using the `:goal` keyword followed by a list of ground literals that describe the desired goal state of the planning problem.
    
-   Actions: declared using the `:action` keyword followed by the name of the action, a list of its parameters enclosed in parentheses, a list of its preconditions enclosed in parentheses after the keyword `:precondition`, and a list of its effects enclosed in parentheses after the keyword `:effect`.
    

The preconditions and effects of an action are defined in terms of predicates and literals that refer to objects and their states. The syntax of PDDL also includes several other keywords and constructs, such as types, functions, and axioms, which provide additional expressivity for specifying planning problems.

#### Example

```ruby
(define (domain blocks)
  (:requirements :strips)
  (:predicates 
    (on ?x - block ?y - block)
    (ontable ?x - block)
    (clear ?x - block)
    (holding ?x - block))
  (:action pick-up
    :parameters (?x - block)
    :precondition (and (clear ?x) (ontable ?x) (not (holding ?x)))
    :effect (and (not (ontable ?x)) (not (clear ?x)) (holding ?x)))
  (:action put-down
    :parameters (?x - block)
    :precondition (holding ?x)
    :effect (and (ontable ?x) (clear ?x) (not (holding ?x))))
  (:action stack
    :parameters (?x - block ?y - block)
    :precondition (and (holding ?x) (clear ?y))
    :effect (and (not (holding ?x)) (not (clear ?y)) (on ?x ?y) (clear ?x)))
  (:action unstack
    :parameters (?x - block ?y - block)
    :precondition (and (on ?x ?y) (clear ?x) (not (holding ?x)))
    :effect (and (holding ?x) (clear ?y) (not (on ?x ?y)))))
```

```ruby
(define (problem blocks-4-0)
  (:domain blocks)
  (:objects a b c d - block)
  (:init 
    (on a b) (on b c) (ontable c) (ontable d) (clear a) (clear d)
    (not (on a c)) (not (on b d)) (not (holding ?x)))
  (:goal (and (on a b) (on b c) (on c d))))
```


### ADL
Action Description Language, which is a formal language used to specify actions and their effects in AI planning. ADL is an <mark style="background: #FFB8EBA6;">extension of STRIPS</mark> (Stanford Research Institute Problem Solver) language and allows the representation of more complex actions with richer preconditions and effects.

ADL representation includes several features such as conditional effects, negative preconditions, quantified preconditions, and disjunctive preconditions. Conditional effects enable the specification of effects that are dependent on the conditions of the action. Negative preconditions allow stating what must not hold true for an action to be applicable. Quantified preconditions and disjunctive preconditions enable the specification of a range of values for the preconditions.

The ADL representation is used by many AI planning systems, including SHOP and C+ +, and provides a more expressive and flexible way of describing actions and their effects, making it easier to develop complex planning problems.


