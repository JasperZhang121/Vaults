Based on the idea that objects that are far away from the others are outliers, proximity-based approaches assume the proximity of an outlier <mark style="background: #FFB86CA6;">deviates significantly</mark> from that of most of the others in the data set.

There are two types of proximity-based outlier detection methods:

- _Distance-based_ outlier detection: An object _o_ is an outlier if its neighbourhood does not have enough other points in it
- _Density-based_ outlier detection: An object _o_ is an outlier if  the density of objects around it is much lower than that of its neighbours

### Distance-Based Outlier Detection: Nested loop method

For a set D of data points, start with a user-defined parameter r called the **distance threshold** that defines a reasonable neighbourhood for each object. For each object o, examine the number of other objects in the r-neighbourhood of o.  <mark style="background: #FFF3A3A6;">If enough of the objects in D are beyond the r-neighbourhood of o, then o should be considered an outlier</mark>. Be careful to exclude o itself when counting the objects in its near neighbourhood.

Formally, let $\pi (0<\pi<1)$ be a fraction threshold, a user-defined parameter that defines what proportion of objects in D are expected to be within the r-neighbourhood of every non-outlying object.

Then an object o is a distance-based outlier DB(r,\pi) if
$$\frac{ {\parallel \{ o' \mid {dist(o,o')}\leq r \} \parallel}} { \parallel D \parallel} < \pi$$
that is, if the proportion of objects in D that are as close as  r  is no more than $\pi$.

Equivalently, one can check the distance between o and its k-nearest neighbour ok, where  k is defined by 
compute k for nearest neighbour   
![[distance_outlier_k_nearest.png]]

In this case, o is an outlier if $\it{dist}(o, o_{k}) > r$

N.B. The upper-square brackets here indicate the ceiling function that rounds any-noninteger value up to the whole number above.
N.B. The formula for DB(r,\pi) given here is corrected from the text book.
