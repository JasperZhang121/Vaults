### Quick identity & repo setup

```bash
git config user.name  "Your Name"                  # set for this repo
git config user.email "you@company.com"
git config --global pull.rebase true               # prefer rebase on pull
git remote -v                                      # check remotes
git branch -vv                                     # see tracking/upstream
```

---

### Unfinished Work Across Machines (WIP flow)

#### 1) Create a temporary branch

```bash
git switch -c temp-in-progress
```

#### 2) Commit your work

```bash
git add -A
git commit -m "WIP: partial implementation of feature X"
```

#### 3) Push for access elsewhere

```bash
git push -u origin temp-in-progress
```

#### 4) Continue at home (or another machine)

```bash
git fetch origin
git switch temp-in-progress
# edit...
git add -A
git commit -m "Continue feature X"
git push
```

#### 5) Merge to main/master when ready

```bash
git switch master       # or: git switch main
git pull                # rebase if configured; else: git pull --rebase
git merge --no-ff temp-in-progress   # or: rebase the temp branch onto master
```

#### 6) Clean up the temp branch

```bash
git branch -d temp-in-progress
git push origin --delete temp-in-progress
```

---

### Stash (quick context switch)

```bash
git stash push -u -m "WIP filters"   # include untracked
git stash list
git stash show -p stash@{0}          # inspect
git stash apply stash@{0}            # keep stash
git stash pop                        # apply + drop
```

---

### Commit like a pro

```bash
git add -p                          # stage hunks interactively
git commit --amend                  # fix last commit content/message
git commit --amend --no-edit --reset-author   # fix last commit author/email
git commit --amend -m "better message"        # rewrite message
```

**Squash / reorder recent commits**

```bash
git rebase -i HEAD~N                # mark "squash"/"fixup"/"reword"
```

**Cherry-pick**

```bash
git cherry-pick <sha>               # apply one commit
git cherry-pick <oldest>^..<newest> # apply a range
# if conflicts:
git cherry-pick --continue | --abort
```

---

### Sync with remote (fetch/pull/push)

```bash
git fetch origin
git pull --rebase                   # keep linear history
git push -u origin <branch>         # set upstream on first push
```

**Force push (safer form)**

```bash
git fetch origin                    # refresh your “lease”
git push --force-with-lease         # current branch → its upstream
# explicit:
git push --force-with-lease origin HEAD:master
```

> If the server protects `master/main`, force pushes will be rejected. Use a feature branch + MR.

---

### Branch management

```bash
git switch -c feat/login            # create & switch
git switch -                        # jump to previous branch
git branch -m old-name new-name     # rename
git push origin --delete old-name   # delete remote
git branch -d old-name              # delete local (merged)
git branch -D old-name              # delete local (force)
```

---

### Diff & inspect

```bash
git status -sb                      # short, branch-aware status
git log --oneline --graph --decorate --all --max-count=30
git show <sha>                      # see one commit
git diff                            # working tree vs index
git diff --staged                   # index vs HEAD
git diff HEAD~1..HEAD               # last commit changes
git blame <file>                    # who last touched which line
# ahead/behind vs origin
git fetch origin
git rev-list --left-right --count HEAD...origin/HEAD
```

---

### Merge & rebase (conflict toolkit)

```bash
git merge <branch>
git rebase <base|origin/master>
# when conflicts:
git status
git add <resolved-files>
git rebase --continue
git rebase --abort                  # bail out
git merge --abort
```

---

### Undo & recovery (the “oh no” section)

**Hard/soft/mixed reset**

```bash
git reset --soft  <sha>   # keep index+working tree (move HEAD only)
git reset --mixed <sha>   # default: keep working tree, unstage changes
git reset --hard  <sha>   # ⚠️ discard index+working tree to <sha>
```

**Restore file(s)**

```bash
git restore <path>                    # discard unstaged changes to path
git restore --staged <path>           # unstage
git restore --source=HEAD <path>      # reset path to HEAD
```

**Revert (make an opposite commit, safe for shared branches)**

```bash
git revert <sha>                      # inverse patch, new commit
git revert --no-edit <oldest>^..<newest>
```

**Time machine**

```bash
git reflog                            # find lost commits/heads
git reset --hard HEAD@{1}             # jump to previous reflog entry
```

---

### Clean working directory

```bash
git clean -fd                         # ⚠️ remove untracked files/dirs
git clean -fdx                        # ⚠️ also remove ignored files
```

---

### Tags & releases

```bash
git tag -a v1.2.3 -m "Release v1.2.3"
git push origin v1.2.3
git push --tags
```

---

### Remotes & housekeeping

```bash
git remote -v
git remote set-url origin https://...
git fetch -p               # prune deleted remote branches
git gc                     # garbage collect, repack
```

---

### Handy aliases (drop in once, use forever)

```bash
git config --global alias.lg "log --oneline --graph --decorate --all"
git config --global alias.st "status -sb"
git config --global alias.last "show -s --format='%h %ad %an %s' --date=short"
git config --global alias.unstage "restore --staged --"
git config --global alias.fp "!git fetch origin && git push --force-with-lease"
```

---

### Practical tips

- Prefer **feature branches + MR**; only fast-forward or clean merges into `master/main`.
    
- Use `--force-with-lease` instead of `--force`.
    
- Before force pushing: `git fetch origin` and re-check `git rev-list --left-right --count`.
    
- When unsure, **revert** on shared branches; use **reset/rebase** on your own branches.
    