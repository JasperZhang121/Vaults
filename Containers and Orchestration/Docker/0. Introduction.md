
Docker is a toolkit for building, shipping, and running applications as **containers**. Containers bundle your app with its runtime, libraries, and OS-level dependencies so it runs the same on your laptop, a CI server, or the cloud.

### Why Docker?

- **Consistency:** “Works on my machine” becomes “works anywhere.”
    
- **Speed:** Start/stop in seconds; great for CI and short-lived tasks.
    
- **Density:** Many containers can share one host (lighter than VMs).
    
- **Dev experience:** Reproducible environments and easy dependency pinning.

### Core concepts (quick map)

- **Image:** Read-only template (e.g., `python:3.11-slim`). Built from a **Dockerfile** and stored in a registry.
    
- **Container:** A running instance of an image (isolated process with its own filesystem, network, and PID space).
    
- **Registry:** Where images live (Docker Hub, GHCR, private registries).
    
- **Layers:** Images are stacked layers; unchanged layers are cached and reused.
    
- **Volume / Bind mount:** Persistent or host-mapped storage for container data.
    
- **Network:** Virtual networks so containers can talk to each other.
    
- **Compose:** YAML to define multi-container apps (`docker compose up`).

### How it works (in one minute)

The **Docker Engine** (daemon) manages images, containers, networks, and volumes. You use the **CLI** to talk to the daemon. When you `docker run` an image, Docker creates a thin, writable layer on top of the image’s read-only layers and starts your process inside a namespaced, cgroup-isolated environment.

### 10-minute quick start

#### 1) Kick the tires

```bash
docker run --rm hello-world
docker run -it --rm alpine:3.20 sh   # tiny Linux; try `apk add curl`
```

#### 2) Build & run your own image

Create a tiny web app:

**`app.py`**

```python
from flask import Flask
app = Flask(__name__)

@app.get("/")
def hello():
    return {"msg": "Hello from Docker!"}
```

**`requirements.txt`**

```
flask==3.0.3
```

**`Dockerfile`**

```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY app.py .
EXPOSE 8000
CMD ["python", "-m", "flask", "--app", "app", "run", "--host=0.0.0.0", "--port=8000"]
```

Build & run:

```bash
docker build -t myflask:dev .
docker run --rm -p 8080:8000 myflask:dev
# open http://localhost:8080
```

#### 3) Add Compose (optional, but comfy)

**`compose.yml`**

```yaml
services:
  web:
    build: .
    ports: ["8080:8000"]
    volumes:
      - .:/app   # live-reload style dev mount (restart on code change)
    environment:
      - FLASK_DEBUG=1
```

Run it:

```bash
docker compose up --build
```


### Everyday commands (cheat sheet)

```bash
# Images & containers
docker images                   # list images
docker ps -a                    # list containers (running/all)
docker run -d --name web -p 8080:8000 myflask:dev
docker logs -f web              # tail logs
docker exec -it web sh          # shell into container
docker stop web && docker rm web
docker rmi IMAGE_ID             # remove image

# Build & tag
docker build -t user/app:1.0 .
docker tag user/app:1.0 registry.example.com/user/app:1.0
docker push registry.example.com/user/app:1.0

# Volumes & networks
docker volume ls
docker network ls
```

### Working with data

- **Anonymous volumes:** `-v /var/lib/data` (managed by Docker).
    
- **Named volumes:** `-v mydata:/var/lib/data` (portable between containers).
    
- **Bind mounts:** `-v $(pwd)/data:/var/lib/data` (live host folder).
    

Use volumes for databases and any state you want to persist across container restarts.

### Networking in a nutshell

- Default **bridge** network isolates containers from the host.
    
- Publish ports with `-p host:container` (e.g., `-p 8080:8000`).
    
- Compose creates a project network; services discover each other by **service name**.

### Image hygiene & best practices

- Start from slim bases (`alpine`, `debian:bookworm-slim`, framework “-slim”).
    
- **Multi-stage builds** to keep runtimes tiny (build tools in stage 1, copy artifacts to stage 2).
    
- Use `.dockerignore` to avoid copying junk (e.g., `.git`, `node_modules`, `__pycache__`).
    
- Pin versions (base image, OS packages, language libs).
    
- Run as a **non-root** user when possible.
    
- Add **HEALTHCHECK** in Dockerfile or Compose.
    
- Keep layers purposeful; combine related RUN steps to reduce layers.

### When _not_ to use Docker

- Heavy, stateful monoliths needing full VM semantics or kernel modules.
    
- Apps requiring privileged host access (unless you know the risks).
    
- Simple scripts where a virtualenv or language runtime is enough.

### Troubleshooting tips

- `docker logs -f <name>` for runtime issues.
    
- `docker exec -it <name> sh` to inspect the live container.
    
- `docker inspect <name>` to see env, mounts, networks.
    
- Rebuild without cache if layer caching bites you: `docker build --no-cache .`
