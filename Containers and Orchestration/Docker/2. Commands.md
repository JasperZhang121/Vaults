### Concepts
- **Image** = packaged filesystem + metadata (read-only).
    
- **Container** = a running process from an image (read-write layer on top).
    
- **Registry** = where images live (Docker Hub, GHCR, private).
    
- **Volume** = Docker-managed persistent storage.
    
- **Bind mount** = map a host folder/file into the container.
    
- **Network** = virtual network(s) for container-to-container comms.


### Install sanity & environment

#### Version, info, disk usage

```bash
docker version
docker info
docker system df             # disk usage summary for images/containers/volumes
docker system prune -af      # ⚠️ removes *dangling & stopped* stuff; add --volumes to clear volumes
```

### Images

#### List, pull, search

```bash
docker images
docker pull alpine:3.20
docker search nginx
```

#### Tag, push (to Docker Hub or private registry)

```bash
docker tag myapp:1.0 registry.example.com/team/myapp:1.0
docker login registry.example.com
docker push registry.example.com/team/myapp:1.0
```

#### Inspect, history

```bash
docker inspect nginx:1.25       # JSON metadata (env, layers, entrypoint…)
docker history nginx:1.25       # layer history
```

#### Export / import images (air-gapped env)

```bash
docker save -o myapp_1.0.tar myapp:1.0
# move file to another machine…
docker load -i myapp_1.0.tar
```

### Container lifecycle

#### Run (common flags)

```bash
# -d: detached; --name: readable name; -p: port; -e: env; -v: volume/bind; --rm: auto-remove on stop
docker run -d --name web -p 8080:80 nginx:1.25

# Interactive shell
docker run -it --rm --name dev alpine:3.20 sh

# With environment and volume
docker run -d --name pg \
  -e POSTGRES_PASSWORD=secret -e POSTGRES_DB=appdb \
  -v pgdata:/var/lib/postgresql/data \
  -p 5432:5432 postgres:14
```

#### Start/stop/restart/kill

```bash
docker stop web
docker start web
docker restart web
docker kill web                  # sends SIGKILL
```

#### List, logs, attach, exec

```bash
docker ps                        # running
docker ps -a                     # all
docker logs -f web               # stream logs
docker attach web                # attach to pid 1 (Ctrl-p Ctrl-q to detach)
docker exec -it web bash         # run a shell *inside* the running container
docker exec web nginx -t         # run arbitrary command
```

#### Copy files in/out

```bash
docker cp ./local.conf web:/etc/nginx/conf.d/local.conf
docker cp web:/var/log/nginx/access.log ./access.log
```

#### Inspect & format output

```bash
docker inspect web | jq '.[0].NetworkSettings.IPAddress'

# Go template formatting:
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web
docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
```

#### Resource limits (CPU/RAM) & updates

```bash
# Hard limits on start
docker run -d --name worker --cpus=1.5 --memory=512m myorg/worker:1.0

# Update running container limits
docker container update --cpus=2 --memory=1g worker
```

#### Clean up

```bash
docker rm -f web dev            # remove containers
docker rmi nginx:1.25           # remove image (unused by any container)
docker volume rm pgdata         # remove volume (make sure it's not in use)
```

### Networking

#### Basics

```bash
docker network ls
docker network inspect bridge
```

#### Create custom bridge network and connect services

```bash
docker network create appnet

docker run -d --name redis --network appnet redis:7
docker run -d --name api --network appnet -p 8080:8080 myorg/api:latest

# Service discovery by *container name* on the same user-defined network:
docker exec -it api sh -c "apt-get update && apt-get install -y dnsutils && dig +short redis"
```

#### Add extra hosts / custom DNS

```bash
docker run --add-host internal.service:10.0.0.5 --dns 1.1.1.1 -it --rm alpine sh
```

### Volumes & data

#### Named volumes vs bind mounts

```bash
# Named volume (managed by Docker)
docker volume create appdata
docker run -d -v appdata:/var/lib/app myorg/app:1.0

# Bind mount (host folder ↔ container)
mkdir -p $(pwd)/conf
docker run -d -v $(pwd)/conf:/etc/app myorg/app:1.0
```

#### Inspect, backup/restore a volume

```bash
docker volume inspect appdata

# Backup a named volume to a tarball
docker run --rm -v appdata:/data -v $(pwd):/backup alpine \
  sh -c "cd /data && tar czf /backup/appdata.tgz ."

# Restore into a (new) named volume
docker volume create appdata2
docker run --rm -v appdata2:/data -v $(pwd):/backup alpine \
  sh -c "cd /data && tar xzf /backup/appdata.tgz"
```

### Building images

#### Minimal Dockerfile (Python Flask example)

```dockerfile
# Dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
USER 1000:1000                   # run as non-root where possible
CMD ["python", "-m", "flask", "--app", "app", "run", "--host=0.0.0.0", "--port=8000"]
```

#### Build with tags, build args, target

```bash
docker build -t myflask:dev .
docker build -t myflask:1.0 --build-arg COMMIT=$(git rev-parse --short HEAD) .
```

#### Multi-stage builds (smaller images)

```dockerfile
# build stage
FROM golang:1.22 AS build
WORKDIR /src
COPY . .
RUN CGO_ENABLED=0 go build -o app ./cmd/server

# run stage
FROM gcr.io/distroless/base-debian12
WORKDIR /app
COPY --from=build /src/app .
EXPOSE 8080
USER 65532:65532
ENTRYPOINT ["/app"]
```

#### BuildKit & buildx (recommended)

```bash
# Enable BuildKit (often default already)
export DOCKER_BUILDKIT=1

# Multi-arch build (example)
docker buildx create --use --name mbuilder
docker buildx build --platform linux/amd64,linux/arm64 -t myorg/app:1.0 --push .
```

### Health checks

#### In Dockerfile

```dockerfile
HEALTHCHECK --interval=10s --timeout=3s --retries=3 CMD curl -f http://localhost:8080/health || exit 1
```

#### In Compose (see below) or inspect status

```bash
docker inspect -f '{{.State.Health.Status}}' web  # healthy / starting / unhealthy
```

### Logs, metrics & events

```bash
docker logs -f --tail=200 web
docker top web                  # processes inside container
docker stats                    # live CPU/mem I/O stats for all containers
docker events                   # live event stream (starts, pulls, health, die)
```

### Filtering, labels, and selection

#### Apply labels & filter by them

```bash
docker run -d --label "app=payments" --label "tier=backend" --name pay1 myorg/pay:1.2
docker ps --filter "label=app=payments"
docker ps --filter "label=tier=backend" --format '{{.Names}}'
```

### Troubleshooting cookbook

#### Get a shell (even if image has no bash)

```bash
docker exec -it web sh || docker exec -it web bash
```

#### Inspect networking/DNS from inside

```bash
docker exec -it web sh -c "cat /etc/hosts; cat /etc/resolv.conf"
docker exec -it web sh -c "apk add --no-cache curl || true; curl -v http://redis:6379 || true"
```

#### See why a container died

```bash
docker ps -a --filter "status=exited"
docker inspect web --format '{{.State.ExitCode}} {{.State.Error}}'
docker logs web
```

#### Nuke everything (⚠️ destructive)

```bash
docker stop $(docker ps -q) 2>/dev/null || true
docker system prune -af --volumes
```

### Real-world service examples

#### NGINX as a static file server

```bash
mkdir -p $(pwd)/site
echo "hello docker" > site/index.html

docker run -d --name www \
  -v $(pwd)/site:/usr/share/nginx/html:ro \
  -p 8080:80 nginx:1.25
```

#### MySQL with a persistent volume and health check

```bash
docker volume create mysqldata
docker run -d --name mysql \
  -e MYSQL_ROOT_PASSWORD=StrongPwd! \
  -e MYSQL_DATABASE=app \
  -v mysqldata:/var/lib/mysql \
  -p 3306:3306 \
  --health-cmd="mysqladmin ping -h localhost -pStrongPwd! || exit 1" \
  --health-interval=10s --health-timeout=5s --health-retries=5 \
  mysql:8.0
```

#### Redis with a password and a custom network

```bash
docker network create backend
docker run -d --name redis --network backend \
  redis:7 redis-server --requirepass "S3cret!"
```

### Docker Compose (v2)

> Prefer `docker compose` (v2). If you still use v1, the command is `docker-compose` with the same subcommands.

#### A typical `compose.yml`

```yaml
services:
  db:
    image: postgres:14
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: app
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5

  api:
    build: ./api
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
      - DB_USER=postgres
      - DB_PASSWORD=secret
      - DB_NAME=app
    depends_on:
      db:
        condition: service_healthy

  web:
    image: nginx:1.25
    ports:
      - "80:80"
    volumes:
      - ./web:/usr/share/nginx/html:ro
    depends_on:
      - api

volumes:
  pgdata:
```

#### Compose commands you’ll use daily

```bash
docker compose up -d                  # start (build if needed)
docker compose up --build -d          # force rebuild
docker compose ps                     # list services
docker compose logs -f api            # logs for one service
docker compose exec api sh            # shell into a service
docker compose restart api            # restart a service
docker compose down                   # stop & remove (keeps volumes)
docker compose down -v                # also remove volumes (⚠️ data loss)
docker compose pull                   # pull latest images for services
docker compose build --no-cache       # rebuild ignoring cache
docker compose config                 # validate & view the merged config
```

#### Profiles (optional: start only a subset)

```yaml
services:
  jaeger:
    image: jaegertracing/all-in-one:1.56
    ports: ["16686:16686"]
    profiles: ["observability"]
```

```bash
docker compose --profile observability up -d
```

### Security & production hygiene (CLI-level quick hits)

- Run as non-root (`USER` in Dockerfile or `--user`).
    
- Pass secrets via orchestrator or runtime secret store (not baked into images).
    
- Keep images small (slim bases, multi-stage).
    
- Pin versions and digest-lock base images (`nginx@sha256:…`).
    
- Use `--read-only` and minimal capabilities when possible:
    

```bash
docker run -d --read-only --cap-drop ALL --cap-add NET_BIND_SERVICE myorg/web:1.0
```

### Advanced/lesser-known commands

```bash
# System
docker builder prune                 # clear build cache
docker image prune -a                # remove unused images
docker events --since 1h             # event stream window

# Container filesystem snapshot
docker export web -o web_fs.tar      # container FS (no image metadata)
docker import web_fs.tar myweb:fs    # create an image from tar FS

# Contexts (remote Docker hosts)
docker context ls
docker context create prod --docker "host=ssh://user@server"
docker context use prod
```

### Quick “what to use when” checklist

- **Run something once?** → `docker run --rm …`
    
- **Persistent service?** → `docker run -d …` or **Compose**
    
- **Multiple services with dependencies?** → **Compose**
    
- **Share data across restarts?** → **Named volume**
    
- **Edit host files live (dev)?** → **Bind mount**
    
- **Debug container failing to start?** → `docker logs`, `docker inspect`, `docker events`
    
- **Ship to another machine?** → `docker push` or `docker save`/`load`

### Copy-paste snippets you’ll reuse

#### Find containers by label and tail logs

```bash
docker ps --filter "label=app=payments" --format '{{.ID}}' \
| xargs -r docker logs --since=10m --tail=200
```

#### Get container’s mapped host port for a given container port

```bash
docker inspect -f '{{(index (index .NetworkSettings.Ports "8080/tcp") 0).HostPort}}' api
```

#### Quickly run a temporary curl tester

```bash
docker run --rm -it curlimages/curl:8.8.0 curl -v http://host.docker.internal:8080/health
```
