
Early days:
![[Pasted image 20221224050102.png]]

<span style="color:yellow">The Address Space:</span>
The address space of a process contains all of the memory state of the running program. For example, the code of the program (the instructions) have to live in memory somewhere, and thus they are in the address space.
![[Pasted image 20221225104056.png]]

The program, while it is running, uses a stack to keep track of where it is in the function call chain as well as to allocate local variables and pass parameters and return values to and from routines. Finally, the heap is used for dynamically-allocated, user-managed memory, such as that you might receive from a call to malloc() in C or new in an objectoriented language such as C++ or Java.

However, this placement of stack and heap is just a convention; you could arrange the address space in a different way if youâ€™d like.

When the OS does this, we say the OS is virtualizing memory, because the running program thinks it is loaded into memory at a particular address (say 0) and has a potentially very large address space (say 32-bits or 64-bits); the reality is quite different.

<span style="color:yellow">Goals of a virtual memory (VM) system :</span>
- transparency
- efficiency
- protection

All memory is vitural, not real:
```C
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char* argv[]) {
	printf("location of code: %p\n", (void*)main);
	printf("location of heap: %p\n", (void*)malloc(1));
	int x = 3;
	printf("location of code: %p\n", (void*) &x);

	return 0;
}
```


<span style="color:yellow">Memory API :</span>

stack memory: allocations and deallocations of it are managed implicitly by the compiler for you, the programmer; for this reason it is sometimes called automatic memory.

```C
void func() {
	int x; 
	// declares an integer on the stack ... 
}
```

The compiler does the rest, making sure to make space on the stack when you call into func(). When your return from the function, the compiler deallocates the memory for you; thus, if you want some information to live beyond the call invocation, you had better not leave that information on the stack.

<br/>
heap memory: allocations and deallocations are explicitly handled by you, the programmer.

It is this need for long-lived memory that gets us to the second type of memory, called heap memory,where all allocations and deallocations are explicitly handled by you, the programmer.

```C
void func() { 
	int *x = (int *) malloc(sizeof(int)); 
}
```

<span style="color:yellow">The malloc() Call :</span>
