
Data Warehouses contain huge volumes of data, yet aim to answer queries in interactive query time time-frames.

One way to deliver fast response times is to pre-compute all the aggregate measures required, at a much increased storage cost.

Data Warehouses must support efficient cube computation, access methods and query processing techniques.

---

#### Data Cube Materialisation

**Data Cubes**

-   A Data cube can be viewed as a lattice of cuboids where each cuboid represents a choice of group-by attributes.    
-   The bottom-most cuboid is the base cuboid
-   The top-most cuboid (apex) contains only one cell

![[data cube.png]]

-   The 3-D base cuboid represents the answer to queries such as  "_What  are the sales for each city, item and year?"._  It is the least generalised (most specific) cuboid.
-   The 2-D  cuboids represent the answer to queries such as  "_What is the sum of sales, grouping by city and item?"._
-   The level-2 1-D cuboids represent the answer to queries such as  _"_What is_ _the sum of sales, grouping by city?".__
-   The  0-D apex cuboid, often denoted **all**,  represents the the answer to "What is the sum of sales?". It is the most generalised (least specific) cuboid.

-   The total number of cuboids for this 3-D data cube is 23 = 8.

---

**Compute cube**

This cube may be only conceptual, but it can also be _materialised_ (that is, pre-computed) in full to reduce run-time query processing costs.

It can be generated by a sequence of  SQL group-by queries, one for each cuboid.

In a generalised syntax, the complete data cube above could be defined by the query

_define cube sales_cube - city, item, year: sum(sales in dollars)_

And it could them be fully materialised as all 8 cuboids by

_compute cube sales_cube_

 In extended SQL by

```sql
SELECT city, item, year, SUM(sales in dollars)

FROM SALES

GROUP BY CUBE  (city, item, year)
```

However, the full materialisation can be useful for fast query response times, but very expensive in storage.

---

