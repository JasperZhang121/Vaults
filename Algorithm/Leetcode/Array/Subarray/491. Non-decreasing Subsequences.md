Given an integer array `nums`, return _all the different possible non-decreasing subsequences of the given array with at least two elements_. You may return the answer in **any order**.

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = set()

        def BT(i,subsequence):
            nonlocal res
            if len(subsequence)>1:
                res.add(tuple(subsequence))
            if i==len(nums):
                return
            
            if not subsequence or nums[i] >= subsequence[-1]:
                BT(i+1, subsequence+[nums[i]]) 
            BT(i+1, subsequence)
        
        BT(0,[])
        return res
```


### Time Complexity

1. **Branching factor & recursion tree size**  
    At each index there are two choices:
    
    - **Include** `nums[index]` (if it keeps the sequence non-decreasing)
        
    - **Exclude** `nums[index]`
        
    
    In the worst case (e.g. when the input is already non-decreasing), you effectively explore both branches at every level. That yields on the order of
    
     $$T(n) = 2 \times T(n-1) + O(1) \quad\Longrightarrow\quad T(n) = O(2^n)$$.
2. **Overhead per recursive call**
    
    - Checking and appending/popping to `output` is O(1).
        
    - When you reach the base case, you may do
        
        ```python
        ans.add(tuple(output))
        ```
        
        which takes $O(k)$ to convert the current sequence of length kk into a tuple.
        
    - In the worst case, many of your valid subsequences will be length ≈n\approx n, so that tuple-conversion step can be $O(n)$.
        
    
    Summing across all the leaves of the recursion tree (there are $O(2^n)$ of them) gives
    
    $O\bigl(2^n \times n\bigr)$.

So the overall **time complexity** is

$$\boxed{O(n \times 2^n)}$$


### Space Complexity

1. **Recursion stack**  
    You recurse at most one level per element, so the call stack depth is $O(n)$.
    
2. **Current path (`output`)**  
    You maintain `output` of at most length nn, so that’s $O(n)$.
    
3. **Answer set (`ans`)**  
    You store each distinct subsequence (of length ≥ 2) as a tuple in a Python `set`.
    
    - In the worst case there are $\Theta(2^n)$ valid subsequences.
        
    - Converting each to a tuple of length up to nn means total storage of up to
        
        $O\bigl(n \times 2^n\bigr)$.

So the overall **auxiliary space** (beyond input) is

$$\boxed{O(n \times 2^n)}$$

dominated by storing all the subsequences, plus the O(n) recursion/output overhead which is subsumed.
