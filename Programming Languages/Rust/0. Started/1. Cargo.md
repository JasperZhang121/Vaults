
### TOML (Tom's Obvious, Minimal Language)

TOML is a configuration file format commonly used in the Rust ecosystem. It stands for "Tom's Obvious, Minimal Language" and is designed to be easy to read and write for both humans and machines. In the context of Rust, TOML files are often used to define project metadata and dependencies.

### [package]

The `[package]` section in a TOML file is used to specify the metadata for a Rust package or crate. It typically includes the following key-value pairs:

- `name`: The name of the package or crate.
- `version`: The version number of the package or crate.
- `authors`: The names or usernames of the authors of the package or crate.
- `edition`: The Rust edition used by the package or crate. The edition determines which version of the Rust language features and standard library are used.

```toml
[package]
name = "my_package"
version = "0.1.0"
authors = ["John Doe", "Jane Smith"]
edition = "2021"
```

### [dependencies]

The `[dependencies]` section in a TOML file is used to specify the dependencies of a Rust package or crate. Dependencies are external libraries or crates that your project relies on. Each dependency is listed as a key-value pair, where the key is the name of the crate and the value is the desired version or a range of versions.

```toml
[dependencies]
crate1 = "0.2.0"
crate2 = "1.5.3"
```

In this example, `crate1` and `crate2` are the names of the dependencies, and the values `"0.2.0"` and `"1.5.3"` specify the desired versions of those dependencies.

### Crate

In Rust, a crate is a compilation unit that can be a library or an executable. It can contain one or more modules that organize and encapsulate related code. Crates are the building blocks of Rust applications and are often published and shared through the Rust package manager, Cargo.

A crate can be either a binary crate or a library crate. A binary crate is an executable that can be run, while a library crate is a reusable collection of code that can be used by other crates. Library crates can be further categorized into two types: `dylib` crates, which are dynamic libraries, and `rlib` crates, which are static libraries.

### cargo new
`cargo new` is a command used in Rust with the Cargo build system to create a new Rust project. It sets up the basic structure and files required for a Rust project, including a `Cargo.toml` file, source code files, and a default project layout.

When you run `cargo new`, it performs the following tasks:

1. Creates a new directory with the specified project name.
2. Sets up a default project structure within the directory.
3. Generates a `Cargo.toml` file, which serves as the project manifest and contains metadata and dependencies for the project.
4. Creates a default source code file (`main.rs`) with a basic "Hello, world!" program.

```
cargo new <project-name>
```

After running `cargo new`, you will have a new directory with the specified project name, containing the following files and directories:

- `Cargo.toml`: The project manifest file that defines the project's metadata and dependencies.
- `src/`: A directory containing the source code files for your project.
    - `main.rs`: A default source code file with a basic "Hello, world!" program.
- `.gitignore` (optional): A file that specifies which files and directories should be ignored by version control systems like Git.
- `target/` (generated after building): A directory that holds the compiled object files, executables, or libraries generated by Cargo.

Once the project is created, you can navigate to the project directory and start working on your Rust code. You can modify the `Cargo.toml` file to add dependencies, specify build settings, and customize your project. The `src/main.rs` file is where you can write your Rust code and begin building your application or library.

After making changes to your project, you can use commands like `cargo build`, `cargo run`, or `cargo test` to compile and run your code, as well as perform various other tasks provided by Cargo.

### Cargo Build/Run

`cargo build` is a command used in Rust to build a Rust project and its dependencies using the Cargo build system. Cargo is the official package manager and build tool for Rust, providing a convenient way to manage dependencies, build projects, and run tests.

When run `cargo build`, it performs the following tasks:

1. Checks the `Cargo.toml` file in the current directory to determine the project configuration, including dependencies, build settings, and metadata.
2. Resolves and fetches the dependencies specified in the `Cargo.toml` file from external sources like crates.io or local paths.
3. Compiles the project's source code and dependencies into object files.
4. Links the object files together to create the final executable or library.

By default, `cargo build` creates a debug build, which includes additional information for debugging purposes. The resulting executable or library is placed in the `target/debug` directory.

Can also customize the build process by specifying build profiles, features, or target platforms using various flags and options with the `cargo build` command. For example:

- `cargo build --release`: Builds the project in release mode, enabling optimizations and producing a smaller, faster executable or library. The output is placed in the `target/release` directory.
- `cargo build --target <target-triple>`: Builds the project for a specific target platform, specified by its target triple. This is useful when cross-compiling for different platforms.
- `cargo build --features <feature-names>`: Builds the project with specific features enabled. Features allow conditional compilation and customization of the project's functionality.
- `cargo build --package <package-name>`: Builds a specific package within a workspace that contains multiple packages.

After running `cargo build`, execute the built program by using `cargo run` or directly run the executable from the `target/debug` or `target/release` directory, depending on the build mode.


### cargo check
`cargo check` is a command used in Rust with the Cargo build system to quickly check the syntax, type checking, and borrow rules of a Rust project without generating an executable or library. It is a useful tool for performing a fast, incremental build and catching errors early in the development process.

When you run `cargo check`, it performs the following tasks:

1. Checks the syntax and parses the source code of your project.
2. Performs type checking to ensure that variables, functions, and expressions are used in a valid and consistent manner.
3. Verifies adherence to the borrow rules and ownership model of Rust, preventing common memory safety issues like data races and use-after-free bugs.

The main difference between `cargo check` and `cargo build` is that `cargo check` skips the code generation and linking steps, resulting in a faster build process. It is especially useful during development when you want to quickly verify the correctness of your code without waiting for the complete build.

By running `cargo check`, you can catch errors and warnings early, allowing you to address them before performing a full build with `cargo build` or running tests with `cargo test`. This can save time by avoiding unnecessary compilation when you are primarily interested in checking for errors or exploring potential issues in your code.

Additionally, `cargo check` can be useful in continuous integration (CI) systems, where quick feedback on the code's validity is crucial, helping identify problems without the need for a full build or test run.

It's important to note that while `cargo check` <mark style="background: #FFB86CA6;">does not generate an executable, it does check the entire project, including dependencies.</mark> This ensures that the project's code is compatible with the used dependencies and their versions, allowing you to catch compatibility issues early in the development process.