### Functions and the `main` Function

- Functions in Rust are declared using the `fn` keyword, followed by the function name and parentheses containing optional parameters.
- The `main` function is the entry point of a Rust program and is where the execution begins.
- The `main` function is defined as `fn main() { ... }` and contains the code to be executed when the program runs.

### Variable Declaration and Mutability

- Variables in Rust are declared using the `let` keyword, followed by the variable name and an optional type annotation.
- By default, variables in Rust are immutable, meaning their values cannot be changed once assigned.
- To declare a mutable variable, use the `mut` keyword before the variable name.
- Mutable variables allow you to modify their values.

### Printing Output with `println!` Macro

- The `println!` macro is used to print output to the console in a formatted manner.
- It starts with `println!` followed by parentheses `( )`, and inside the parentheses, you provide a format string followed by the values to be inserted into the placeholders.
- Placeholders are represented by curly braces `{}` within the format string, and the corresponding values are passed after the format string.

### Data Types and Type Annotations

- Rust is a statically-typed language, which means variables must have a declared type at compile time.
- Rust provides various built-in data types such as integers, floating-point numbers, booleans, characters, strings, and more.
- Type annotations can be added to variables using the colon `:` followed by the desired type.

### Control Flow Statements

- Rust supports standard control flow statements like `if` expressions, `loop` loops, `while` loops, and `for` loops.
- `if` expressions are used for conditional branching, and the condition must be a boolean expression.
- `loop` creates an infinite loop that can be terminated using the `break` statement.
- `while` loops execute a block of code as long as the specified condition is true.
- `for` loops iterate over a range or collection of items.

### Error Handling with `Result` and `match`

- Rust emphasizes error handling through the `Result` enum and the `match` expression.
- Functions that can potentially fail return a `Result` type, which represents the possibility of success (`Ok`) or failure (`Err`).
- The `match` expression is used to handle different outcomes or errors returned by a `Result`.
- It allows pattern matching against different possible `Result` variants and executing corresponding code blocks.

These notes cover the basic syntax elements of Rust, including function declaration, variable declaration and mutability, printing output, data types, type annotations, control flow statements, and error handling using `Result` and `match`.

```rust
fn main() {
    // Variable Declaration and Mutability
    let immutable_var = 42;
    let mut mutable_var = String::from("Hello");

    // Printing Output with println! Macro
    println!("The value of immutable_var is: {}", immutable_var);
    println!("The value of mutable_var is: {}", mutable_var);

    // Data Types and Type Annotations
    let number: i32 = 10;
    let is_true: bool = true;
    let character: char = 'A';
    let greeting: &str = "Hello, world!";

    println!("Number: {}", number);
    println!("Boolean: {}", is_true);
    println!("Character: {}", character);
    println!("Greeting: {}", greeting);

    // Control Flow Statements
    if number > 5 {
        println!("Number is greater than 5");
    } else {
        println!("Number is less than or equal to 5");
    }

    let mut counter = 0;
    loop {
        counter += 1;
        println!("Counter: {}", counter);

        if counter >= 5 {
            break;
        }
    }

    let mut while_counter = 0;
    while while_counter < 3 {
        println!("While Counter: {}", while_counter);
        while_counter += 1;
    }

    for i in 0..3 {
        println!("For Loop Counter: {}", i);
    }

    // Error Handling with Result and match
    let result: Result<i32, &str> = Ok(42);

    match result {
        Ok(value) => println!("Result: {}", value),
        Err(error) => println!("Error: {}", error),
    }
}
```