
> Spring’s **RestTemplate** is a synchronous (blocking) HTTP client for REST calls. While **WebClient** is the recommended modern alternative (since Spring 5), RestTemplate remains widely used for its simplicity and great integration with Spring MVC. This note consolidates setup, usage patterns, error handling, resilience, and side-by-side comparisons with alternatives.

---

### 1) When (and when not) to use RestTemplate

- **Use RestTemplate when**
    
    - Your app is **blocking / thread-per-request** (Spring MVC).
        
    - You need a **simple** HTTP client with minimal ceremony.
        
- **Prefer alternatives when**
    
    - You need **non-blocking high concurrency** → **WebClient**.
        
    - You want **declarative** clients for microservices → **OpenFeign**.
        
    - You need **fine-grained** control over sockets/TLS/pooling → **Apache HttpClient** / **OkHttp**.
        

---

### 2) Setting up RestTemplate

#### 2.1 Minimal bean (with load balancing if needed)

```java
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```

```java
// Use service discovery + client-side load balancing (Spring Cloud LoadBalancer)
@Bean
@LoadBalanced
public RestTemplate loadBalancedRestTemplate() {
    return new RestTemplate();
}
```

#### 2.2 Timeouts (simple factory)

```java
@Bean
public RestTemplate timeoutRestTemplate() {
    var f = new SimpleClientHttpRequestFactory();
    f.setConnectTimeout(5000);
    f.setReadTimeout(5000);
    return new RestTemplate(f);
}
```

#### 2.3 Connection pooling (Apache HttpClient 5)

```java
@Bean
public RestTemplate pooledRestTemplate() {
    var cm = org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder.create()
        .setMaxConnTotal(200)
        .setMaxConnPerRoute(50)
        .build();

    var httpClient = org.apache.hc.client5.http.impl.classic.HttpClients.custom()
        .setConnectionManager(cm)
        .evictExpiredConnections()
        .build();

    var factory = new HttpComponentsClientHttpRequestFactory(httpClient);
    factory.setConnectTimeout(3000);
    factory.setReadTimeout(5000);

    var rt = new RestTemplate(factory);
    // Converters (Jackson is auto-configured in Spring Boot)
    // rt.getMessageConverters().add(new MappingJackson2HttpMessageConverter());

    // Interceptors (headers, tracing, logging)
    rt.getInterceptors().add((req, body, exec) -> {
        req.getHeaders().add("X-Request-Id", java.util.UUID.randomUUID().toString());
        return exec.execute(req, body);
    });

    // Optional: custom error handling (see §5)
    // rt.setErrorHandler(new CustomResponseErrorHandler());
    return rt;
}
```

#### 2.4 Message converters & error handlers (customization)

```java
var rt = new RestTemplate();
rt.getMessageConverters().add(new MappingJackson2HttpMessageConverter()); // JSON
rt.setErrorHandler(new CustomResponseErrorHandler());
```

---

### 3) Building requests

#### 3.1 URL construction (path vars + query params)

```java
// Path variables
String url = "https://api.example.com/users/{id}";
UserDto user = restTemplate.getForObject(url, UserDto.class, 42);

// Query parameters
URI uri = UriComponentsBuilder.fromHttpUrl("https://api.example.com/search")
    .queryParam("q", "spring resttemplate")
    .queryParam("page", 1)
    .build(true)  // don't re-encode already encoded parts
    .toUri();
ResponseEntity<String> resp = restTemplate.getForEntity(uri, String.class);
```

#### 3.2 Headers & entities (JSON / auth)

```java
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
headers.setBearerAuth("<token>");  // or headers.setBasicAuth("user","pass");

CreateUserReq payload = new CreateUserReq("Jasper", "admin");
HttpEntity<CreateUserReq> entity = new HttpEntity<>(payload, headers);

ResponseEntity<UserDto> created = restTemplate.postForEntity(
    "https://api.example.com/admin/users", entity, UserDto.class);
```

#### 3.3 Form-urlencoded

```java
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
form.add("username", "alice");
form.add("password", "secret");

ResponseEntity<String> login = restTemplate.postForEntity(
    "https://example.com/login", new HttpEntity<>(form, headers), String.class);
```

#### 3.4 Multipart file upload

```java
FileSystemResource file = new FileSystemResource("/path/report.pdf");
MultiValueMap<String,Object> parts = new LinkedMultiValueMap<>();
parts.add("file", file);
parts.add("comment", "Quarterly report");

HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.MULTIPART_FORM_DATA);

ResponseEntity<UploadResp> up = restTemplate.postForEntity(
    "https://files.example.com/upload", new HttpEntity<>(parts, headers), UploadResp.class);
```

---

### 4) Executing requests (verbs & flexible `exchange`)

#### 4.1 Common shortcuts

```java
// GET
UserDto dto = restTemplate.getForObject(url, UserDto.class);
ResponseEntity<UserDto> ge = restTemplate.getForEntity(url, UserDto.class);

// POST
UserDto created = restTemplate.postForObject(url, entityOrBody, UserDto.class);
ResponseEntity<UserDto> pe = restTemplate.postForEntity(url, entityOrBody, UserDto.class);
URI location = restTemplate.postForLocation(url, entityOrBody);

// PUT / DELETE
restTemplate.put(url, entityOrBody);
restTemplate.delete(url);
```

#### 4.2 `exchange` for full control (headers, method, generics)

```java
ResponseEntity<ApiResult<List<UserDto>>> res = restTemplate.exchange(
    url,
    HttpMethod.POST,
    httpEntity,                      // includes headers/body
    new ParameterizedTypeReference<ApiResult<List<UserDto>>>() {}
);
```

#### 4.3 Streaming download (avoid loading entire file in memory)

```java
RequestCallback rc = req -> req.getHeaders().setAccept(List.of(MediaType.ALL));
ResponseExtractor<Void> re = response -> {
  try (var in = response.getBody();
       var out = Files.newOutputStream(Path.of("/tmp/big.zip"))) {
    in.transferTo(out);
  }
  return null;
};
restTemplate.execute("https://example.com/big.zip", HttpMethod.GET, rc, re);
```

---

### 5) Handling responses & errors

#### 5.1 Inspect status/headers/body

```java
ResponseEntity<UserDto> resp = restTemplate.getForEntity(url, UserDto.class);
if (resp.getStatusCode().is2xxSuccessful()) {
    UserDto body = resp.getBody();
    HttpHeaders respHeaders = resp.getHeaders();
}
```

#### 5.2 Default exception style (throws on 4xx/5xx)

```java
try {
  var r = restTemplate.getForEntity(url, String.class);
} catch (HttpClientErrorException e) {        // 4xx
  log.warn("Client error {} body={}", e.getStatusCode(), e.getResponseBodyAsString());
} catch (HttpServerErrorException e) {        // 5xx
  log.error("Server error {} body={}", e.getStatusCode(), e.getResponseBodyAsString());
} catch (ResourceAccessException e) {         // timeouts, I/O
  log.error("I/O error: {}", e.getMessage(), e);
}
```

#### 5.3 Lenient `ResponseErrorHandler` (don’t throw; you decide)

```java
public class CustomResponseErrorHandler implements ResponseErrorHandler {
    @Override public boolean hasError(ClientHttpResponse response) { return false; }
    @Override public void handleError(ClientHttpResponse response) { /* no-op */ }
}
```

> Use this for admin/validation flows where **404 should be treated as “endpoint invalid”** but **401/403/405/5xx still prove reachability**.

---

### 6) Internal vs external calls

#### 6.1 Internal microservices (service discovery)

```java
// With @LoadBalanced RestTemplate and Nacos/Eureka/Spring Cloud LB configured:
OrderDto order = restTemplate.getForObject(
    "http://order-service/api/orders/{id}", OrderDto.class, 1001L);
```

#### 6.2 External websites/APIs

- JSON APIs → map to DTOs (Jackson).
    
- HTML pages → fetch as `String` then parse with **Jsoup** separately.
    
- For **proxies/cookies/redirects/TLS**, prefer Apache HttpClient/OkHttp request factories.
    

---

### 7) Resilience: retries, timeouts, circuit breakers

- Use **separate** timeouts: Connect (2–3s) vs Read (5–8s).
    
- Add **Resilience4j** for retries with backoff/jitter, and circuit breakers:
    

```java
Supplier<ResponseEntity<UserDto>> s = () -> restTemplate.getForEntity(url, UserDto.class);
Supplier<ResponseEntity<UserDto>> decorated = Decorators.ofSupplier(s)
    .withRetry(retry)
    .withCircuitBreaker(circuitBreaker)
    .decorate();
ResponseEntity<UserDto> r = Try.ofSupplier(decorated).get();
```

---

### 8) Security notes

- Prefer **HTTPS**; validate certificates (avoid “trust-all” in prod).
    
- Keep **tokens/keys** out of logs and configs; use **Vault/Secrets**.
    
- If you save **admin-configurable URLs**, validate them with a **HEAD probe** (tight timeouts) and **anti-SSRF checks** (no localhost/private IPs; re-validate after redirects).
    

---

### 9) Testing

- **Unit tests**: mock `RestTemplate` / stub `exchange` responses.
    

```java
@MockBean RestTemplate restTemplate;
// when(restTemplate.exchange(...)).thenReturn(ResponseEntity.ok(new UserDto(...)));
```

- **Integration tests**: WireMock/httpbin/docker-compose to simulate HTTP behavior.
    

---

### 10) Best-practice checklist

-  Define a **singleton** RestTemplate bean; reuse it (thread-safe after construction).
    
-  Set **connect/read timeouts**; avoid infinite waits.
    
-  Use **pooled** client factory for high throughput.
    
-  Centralize **converters**, **interceptors**, **error handler**.
    
-  Use `exchange` + `ParameterizedTypeReference` for generics.
    
-  Add **metrics/logging** (Micrometer) tagged by route/status.
    
-  Apply **resilience** (retry/circuit breaker) where appropriate.
    

---

### 11) Alternatives (with code) & comparison

#### 11.1 WebClient (reactive, recommended for new apps)

```java
WebClient wc = WebClient.builder().baseUrl("https://api.example.com").build();

// GET
UserDto u = wc.get().uri("/users/{id}", 42)
    .retrieve()
    .bodyToMono(UserDto.class)
    .block(); // block only in blocking flows

// POST JSON
UserDto created = wc.post().uri("/admin/users")
    .contentType(MediaType.APPLICATION_JSON)
    .bodyValue(Map.of("name","Jasper"))
    .retrieve()
    .onStatus(HttpStatusCode::is4xxClientError, r -> r.createException())
    .bodyToMono(UserDto.class)
    .block();
```

**Pros:** non-blocking, high throughput, rich filters, great timeout control.  
**Cons:** reactive learning curve; avoid blocking in reactive pipelines.

#### 11.2 OpenFeign (declarative microservice client)

```java
@FeignClient(name = "user-service", path = "/api/users")
public interface UserClient {
  @GetMapping("/{id}") UserDto byId(@PathVariable Long id);
  @PostMapping UserDto create(@RequestBody CreateUserReq req);
}
```

**Pros:** interface-based, integrates with discovery/LB/resilience; minimal boilerplate.  
**Cons:** less raw HTTP control; interface sprawl for many endpoints.

#### 11.3 OkHttp (low-level, modern)

```java
OkHttpClient client = new OkHttpClient.Builder()
    .connectTimeout(Duration.ofSeconds(3))
    .readTimeout(Duration.ofSeconds(5))
    .build();
Request req = new Request.Builder().url("https://api.example.com/users/42").build();
try (Response res = client.newCall(req).execute()) {
    if (res.isSuccessful()) {
        String body = res.body().string();
    }
}
```

**Pros:** lean, fast, HTTP/2. **Cons:** manual JSON/resilience.

#### 11.4 Apache HttpClient 5 (low-level, enterprise features)

- Powerful for **proxy/cookie/TLS/pooling**; more verbose to map responses manually.
    

##### Quick comparison

|Client|Model|Best for|Pros|Cons|
|---|---|---|---|---|
|RestTemplate|Blocking|Simple calls in MVC apps|Easy, familiar, Spring-native|Maintenance mode; fewer advanced ops|
|WebClient|Reactive|High concurrency / streaming|Non-blocking, rich filters, timeout control|Reactive learning curve|
|OpenFeign|Declarative|Internal microservices (discovery/LB)|Interface-based, minimal boilerplate|Less raw HTTP control|
|HttpClient 5|Low-level|Custom TLS/proxy/cookie/pooling needs|Enterprise features, powerful|Verbose|
|OkHttp 4|Low-level|Lightweight clients, HTTP/2|Simple, fast|Manual mapping/resilience|

---

### 12) Example: end-to-end POST with logging & checks

```java
@Component
public class ExampleClient {

    private final RestTemplate restTemplate;
    private final ObjectMapper mapper = new ObjectMapper();

    public ExampleClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public YourResponseType createResource(String serviceName, YourRequestType request) throws JsonProcessingException {
        String url = "http://" + serviceName + "/resource/create";

        log.info("POST {}", url);
        log.debug("Request body: {}", mapper.writeValueAsString(request));

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<YourRequestType> entity = new HttpEntity<>(request, headers);

        ResponseEntity<YourResponseType> response = restTemplate.exchange(
            url, HttpMethod.POST, entity, YourResponseType.class
        );

        if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
            log.info("Success: {}", response.getBody());
            return response.getBody();
        }
        log.error("Failed [{}] {}: {}", response.getStatusCodeValue(), response.getStatusCode(), response.getBody());
        throw new RuntimeException("Resource creation failed: " + response.getStatusCode());
    }
}
```

---

### 13) Placement suggestion

- `14. Spring/3. Web/RestTemplate Deep Dive & Alternatives.md`  
    **or**
    
- `15. SpringBoot/10. Rest Clients - RestTemplate vs WebClient vs Feign.md`
    

> This final note merges your existing summary (DI, `@LoadBalanced`, converters, custom `ResponseErrorHandler`, `exchange`, generics, status/header checks, logging, exceptions, testing) with deeper recipes (multipart/streaming, pooling timeouts, resilience, internal/external patterns, alternatives and comparisons).