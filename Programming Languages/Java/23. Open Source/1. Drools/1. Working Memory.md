
In Drools and other rule engines, **Working Memory** refers to the <mark style="background: #FFB8EBA6;">runtime data store where all facts (objects) are inserted and held during rule evaluation and execution</mark>.

It is the core component that the rule engine uses to match conditions (LHS – left-hand side) of rules. Rules are evaluated based on the contents of the working memory. <mark style="background: #FFB86CA6;">When facts are added, updated, or removed from working memory, the rule engine automatically re-evaluates applicable rules</mark>.

### How It Works

- When a fact (like a Java object) is inserted using `kieSession.insert(fact)`, it becomes part of working memory.
    
- The rule engine then evaluates all rule conditions against the current state of working memory.
    
- If the condition (`when`) of a rule is satisfied by the facts in working memory, the rule is **activated** and eventually **fired**.
    
- When rules execute (`then` block), they can update or remove facts in working memory, which may in turn activate more rules — a process known as **rule chaining**.
    

### Lifecycle of Facts in Working Memory

1. **Insert**
    
    ```java
    kieSession.insert(order);
    ```
    
    Adds a new object into working memory.
    
2. **Update**
    
    ```java
    order.setPrice(250);
    kieSession.update(factHandle);
    ```
    
    Updates an existing fact. Requires a `FactHandle` reference.
    
3. **Retract (Delete)**
    
    ```java
    kieSession.delete(factHandle);
    ```
    
    Removes a fact from working memory.
    

### FactHandle

A `FactHandle` is a reference to a fact in working memory. It's used for updating or retracting the fact. Drools assigns a unique handle to each inserted fact:

```java
FactHandle handle = kieSession.insert(student);
kieSession.update(handle, student);
kieSession.delete(handle);
```


**Code Example: FactHandle in Action**

```java
public class FactHandleExample {
    public static void main(String[] args) {
        KieSession kieSession = KieServices.Factory.get()
            .getKieClasspathContainer()
            .newKieSession();

        // Insert a fact
        Student student = new Student("Alice", 12);
        FactHandle handle = kieSession.insert(student);

        // Modify the fact and update
        student.setAge(15); // Change property
        kieSession.update(handle, student); // Notify Drools to re-evaluate rules

        // Remove the fact
        kieSession.delete(handle); // Now the fact is gone from working memory

        kieSession.dispose();
    }
}
```


### Example Scenario

In a medical diagnosis system:

- All patient symptoms and test results are inserted into working memory as facts.
    
- Rules for diagnosing conditions check these facts to match patterns.
    
- If a rule is triggered (e.g., "high fever + cough → suspect flu"), the diagnosis is added as a new fact.
    
- New diagnoses can trigger additional rules (e.g., "if flu is diagnosed, recommend rest and fluids").
    

### Key Points

- Working memory is **stateful** — it holds data for rule evaluation during the session.
    
- It supports **reactive evaluation** — any change in facts can re-trigger rule evaluations.
    
- It forms the foundation for **forward chaining**, where the results of one rule may influence the activation of others.
    
- It is **cleared when the session ends**, unless you're using stateful sessions designed to persist.
    
