### Drools Usage in Spring Boot (as a Decision Service)

In a modern Spring Boot application, Drools is typically embedded as a **decision component** rather than a standalone engine. Spring Boot provides HTTP, configuration, security, etc., while Drools focuses on **business rules** such as validation, pricing, discount policies, and risk scoring. The common pattern is:

> **Spring Boot REST endpoint** → map input DTOs to domain objects → **Drools session** executes rules → return enriched/validated result.

---

### 1. Project Layout and Dependencies

A minimal Maven project often has:

```text
src/
  main/
    java/
      com.example.demo/
        DroolsConfig.java
        DiscountController.java
        domain/
          Order.java
          Customer.java
    resources/
      META-INF/
        kmodule.xml
      rules/
        discount.drl
```

Maven dependencies (simplified):

```xml
<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Drools core API -->
    <dependency>
        <groupId>org.kie</groupId>
        <artifactId>kie-api</artifactId>
    </dependency>
    <dependency>
        <groupId>org.drools</groupId>
        <artifactId>drools-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.drools</groupId>
        <artifactId>drools-compiler</artifactId>
    </dependency>
</dependencies>
```

`kmodule.xml` defines the knowledge base and sessions:

```xml
<kmodule xmlns="http://www.drools.org/xsd/kmodule">

  <kbase name="rulesBase" packages="rules">
    <ksession name="ksession-stateless" type="stateless"/>
    <ksession name="ksession-stateful"  type="stateful"/>
  </kbase>

</kmodule>
```

The DRL file (e.g. `rules/discount.drl`) is kept in `src/main/resources/rules`.

---

### 2. Spring Configuration: Wiring Drools into the Context

A typical Spring Boot configuration class exposes Drools artifacts as beans:

```java
@Configuration
public class DroolsConfig {

    @Bean
    public KieContainer kieContainer() {
        KieServices kieServices = KieServices.Factory.get();
        return kieServices.getKieClasspathContainer();
    }

    @Bean
    public StatelessKieSession statelessKieSession(KieContainer kieContainer) {
        return kieContainer.newStatelessKieSession("ksession-stateless");
    }

    @Bean
    public KieSession statefulKieSession(KieContainer kieContainer) {
        return kieContainer.newKieSession("ksession-stateful");
    }
}
```

This integrates Drools into the Spring IOC container:

- `KieContainer` is created once and reused.
    
- `StatelessKieSession` bean is used for “one-shot” evaluations.
    
- `KieSession` bean is available for stateful scenarios (if needed).
    

In many REST-style decision services, only the **stateless** session is used.

---

### 3. Example DRL: Discount Rule

`src/main/resources/rules/discount.drl`:

```drl
package rules

import com.example.demo.domain.Order
import com.example.demo.domain.Customer

global java.util.List debugMessages;

rule "VIP high-value discount"
when
    $c : Customer( vip == true )
    $o : Order( customerId == $c.id, total > 1000 )
then
    double old = $o.getDiscount();
    $o.setDiscount(0.20); // 20% discount
    debugMessages.add("Applied VIP discount, old=" + old + ", new=0.20");
end

rule "Non-VIP basic discount"
salience -10
when
    $c : Customer( vip == false )
    $o : Order( customerId == $c.id, total > 500, total <= 1000 )
then
    $o.setDiscount(0.05);
    debugMessages.add("Applied basic discount 5%");
end
```

This is purely declarative: it does not know about HTTP, controllers, or databases. It only expresses **when** a discount should be applied and **how**.

---

### 4. Stateless Decision Endpoint in Spring Boot

We now expose a REST endpoint that uses the stateless session per request.

Domain objects:

```java
public class Customer {
    private String id;
    private boolean vip;
    // getters/setters/constructors omitted
}

public class Order {
    private Long id;
    private String customerId;
    private double total;
    private double discount; // result field
    // getters/setters/constructors omitted
}
```

Controller:

```java
@RestController
@RequestMapping("/api/discount")
public class DiscountController {

    private final StatelessKieSession statelessKieSession;

    public DiscountController(StatelessKieSession statelessKieSession) {
        this.statelessKieSession = statelessKieSession;
    }

    @PostMapping
    public DiscountResult evaluate(@RequestBody DiscountRequest request) {
        Customer customer = new Customer(request.getCustomerId(), request.isVip());
        Order order = new Order(request.getOrderId(),
                                request.getCustomerId(),
                                request.getTotal());

        List<Object> facts = new ArrayList<>();
        List<String> debugMessages = new ArrayList<>();

        facts.add(customer);
        facts.add(order);

        // make debug list visible to rules via a global
        statelessKieSession.setGlobal("debugMessages", debugMessages);

        // execute rules in one shot
        statelessKieSession.execute(facts);

        // assemble response: rules may have modified 'order'
        DiscountResult result = new DiscountResult();
        result.setOrderId(order.getId());
        result.setAppliedDiscount(order.getDiscount());
        result.setFinalAmount(order.getTotal() * (1 - order.getDiscount()));
        result.setDebugMessages(debugMessages);

        return result;
    }
}
```

Request/response DTOs (simplified):

```java
public class DiscountRequest {
    private Long orderId;
    private String customerId;
    private boolean vip;
    private double total;
    // getters/setters
}

public class DiscountResult {
    private Long orderId;
    private double appliedDiscount;
    private double finalAmount;
    private List<String> debugMessages;
    // getters/setters
}
```

In this design:

- Each HTTP request constructs **fresh facts** (`Customer`, `Order`, `debugMessages`).
    
- `statelessKieSession.execute(...)` performs:
    
    - Insert all facts into a transient working memory.
        
    - Evaluate and fire all applicable rules.
        
    - Dispose the internal session automatically.
        
- The response reflects the decisions taken by Drools (discount and final amount).
    

This is the canonical “Drools + Spring Boot” usage: **a stateless decision microservice**.

---

### 5. Notes on Stateful Session Usage in Spring Boot

While stateless usage is dominant for REST-style decision services, some applications require **stateful** sessions, for example:

- Long-running conversational flows.
    
- Monitoring of events over time with temporal rules.
    
- Session-scoped or user-scoped rule contexts.
    

Patterns (high level):

- Inject a `KieSession` and scope it appropriately:
    
    - As a singleton per application (careful about concurrency).
        
    - Or per HTTP session / per workflow instance.
        
- Maintain `FactHandle`s to update and retract facts as the system state evolves.
    
- Explicitly call `ksession.fireAllRules()` when new facts or updates arrive.
    

For example, in a WebSocket or scheduled-task context, the service periodically inserts/updates facts and fires rules to detect anomalies.

---

### 6. Best Practices for Drools in Spring Boot

1. **Isolate rule logic**  
    Keep complex Java logic outside DRL. Use DRL to express _conditions_ and _high-level actions_, while delegating heavy computation to services.
    
2. **Prefer stateless sessions for HTTP**  
    For typical REST APIs, `StatelessKieSession` is simpler, thread-safe at the API level, and fits the “request–response” style.
    
3. **Version and test rules**  
    Treat DRL as code:
    
    - Put under version control.
        
    - Write unit tests that call the Drools layer directly (without HTTP).
        
4. **Use clear packages and kmodule layout**  
    Group related rules in the same package and KieBase. Name sessions (`ksession-stateless`, `ksession-stateful`) meaningfully.
    
5. **Monitor rule behavior in logs**  
    For debugging, add globals like `debugMessages` or use Drools event listeners to trace which rules fired for which inputs.