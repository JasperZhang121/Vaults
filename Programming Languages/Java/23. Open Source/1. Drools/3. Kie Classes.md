### `KieServices` & `KieContainer`

**Role:** Entry point and container of compiled rule modules.

- `KieServices`: Singleton factory / service locator for all KIE objects.
    
- `KieContainer`: Holds one KIE module (KJAR) and exposes named `KieBase` / `KieSession` definitions.
    

**Typical usage**

```java
import org.kie.api.KieServices;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;

KieServices ks = KieServices.Factory.get();

// load rules from classpath (kmodule.xml + DRL)
KieContainer container = ks.getKieClasspathContainer();

// create a stateful session defined in kmodule.xml
KieSession ksession = container.newKieSession("ksession-rules");

ksession.insert(new Order(1L, 1500.0));
ksession.fireAllRules();
ksession.dispose();
```

---

### `KieBase` & `KieSession` & `StatelessKieSession`

**Role:** Compiled knowledge base and its runtimes.

- `KieBase`
    
    - Immutable compiled rules, queries, processes, etc.
        
    - From one `KieBase` you can create many sessions.
        
- `KieSession` (stateful)
    
    - Holds _working memory_ + rule engine.
        
    - Supports `insert / update / delete`, multiple `fireAllRules()`.
        
    - For scenarios with evolving state (monitoring, workflows).
        
- `StatelessKieSession`
    
    - One-shot execution (no persistent state).
        
    - For pure “request → decision → response” style.
        

**Typical usage**

_Stateful:_

```java
KieBase kbase = container.getKieBase("rulesBase");
KieSession ksession = kbase.newKieSession();

Order order = new Order(1L, 500.0);
ksession.insert(order);
ksession.fireAllRules();
ksession.dispose();
```

_Stateless:_

```java
StatelessKieSession stateless = container.newStatelessKieSession("stateless-rules");

Order order = new Order(1L, 2000.0);
Customer customer = new Customer("C001", true);

stateless.execute(Arrays.asList(order, customer));
// rules may modify order / customer directly
```

---

### `FactHandle`

**Role:** Stable reference to a fact inside a `KieSession`.

- Returned when inserting a fact into a **stateful** session.
    
- Used to `update` or `delete` a specific fact in working memory.
    
- Required because the engine maintains its own identity / indexing structure.
    

**Typical usage**

```java
KieSession ksession = kbase.newKieSession();

Order order = new Order(1L, 500.0);

// insert and keep handle
FactHandle fh = ksession.insert(order);
ksession.fireAllRules();

// modify fact and notify engine
order.setTotal(2000.0);
ksession.update(fh, order);
ksession.fireAllRules();

// remove when no longer needed
ksession.delete(fh);
ksession.dispose();
```

---

### `KieFileSystem` & `KieBuilder` (dynamic rules)

**Role:** Programmatic build of rules (no static kmodule needed).

- `KieFileSystem`
    
    - In-memory “project” where you write DRL, kmodule.xml, etc.
        
- `KieBuilder`
    
    - Compiles `KieFileSystem` into a `KieModule`.
        
    - Used for dynamic / runtime rule loading.
        

**Typical usage**

```java
KieServices ks = KieServices.Factory.get();

// 1. Build rules from a string
String drl =
    "package demo;\n" +
    "rule \"Hello\" when\n" +
    "  $s : String( this == \"hello\" )\n" +
    "then\n" +
    "  System.out.println(\"Fired: \" + $s);\n" +
    "end\n";

KieFileSystem kfs = ks.newKieFileSystem();
kfs.write("src/main/resources/demo/hello.drl", drl);

// 2. Compile
KieBuilder kb = ks.newKieBuilder(kfs).buildAll();
if (kb.getResults().hasMessages(org.kie.api.builder.Message.Level.ERROR)) {
    throw new IllegalStateException("Build errors: " + kb.getResults());
}

// 3. Use resulting module
KieContainer dynamicContainer = ks.newKieContainer(kb.getKieModule().getReleaseId());
KieSession ksession = dynamicContainer.newKieSession();
ksession.insert("hello");
ksession.fireAllRules();
ksession.dispose();
```

---

### `KieScanner` (hot-deploy KJAR)

**Role:** Automatically refresh `KieContainer` from Maven repository.

- Watches a Maven GAV (`groupId:artifactId:version`) for updates.
    
- When a new KJAR is deployed, it updates the container to the new version.
    
- Used for continuous rule deployment without app redeploy.
    

**Typical usage**

```java
KieServices ks = KieServices.Factory.get();
ReleaseId rid = ks.newReleaseId("com.example", "rules-kjar", "1.0.0");

KieContainer container = ks.newKieContainer(rid);
KieScanner scanner = ks.newKieScanner(container);

// check every 10 seconds
scanner.start(10_000L);

// later the KJAR is updated in repo; scanner auto-updates container

KieSession ksession = container.newKieSession();
ksession.insert(new Order(1L, 2000.0));
ksession.fireAllRules();
ksession.dispose();

scanner.stop();
```
