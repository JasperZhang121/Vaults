**Separation of concerns.** Conductor deliberately **separates the primary state store from the indexing/search layer**. The classic OSS deployment used a <mark style="background: #FFB8EBA6;">Redis/Dynomite–based state</mark> store with **Elasticsearch** for search and UI queries; both layers are **pluggable** and can be swapped independently. ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/index.html "Architecture Overview - Conductor Documentation"))
	
**Historical & current backends.**

- **Redis/Dynomite + Elasticsearch (OSS default):** The `conductor-redis-persistence` path stores workflow/task state in Dynomite/Redis, while **indexing** (for searching executions, UI filters, and archival queries) is done in **Elasticsearch**. ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/index.html "Architecture Overview - Conductor Documentation"))
    
- **PostgreSQL option:** Conductor can run **entirely on PostgreSQL** for workflow metadata, **queues**, **indexing**, and **locking**—reducing moving parts, with the trade-off that it “**does not scale as well**” for very high volumes. Enabling Postgres is just config (`conductor.db.type=postgres`), and you can also choose Postgres for `queue.type` and `indexing.type`. ([Conductor OSS](https://conductor-oss.github.io/conductor/documentation/advanced/postgresql.html "PostgreSQL - Conductor Documentation"))
    

**Indexing is decoupled from persistence.** Starting with Conductor 2.x, **indexing is not in the critical execution path** and is maintained as a separate module, improving reliability and letting you mix an in-memory/Redis store with an external indexer (or vice versa). ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/technicaldetails.html "Technical Details - Conductor Documentation"))

**Queue providers are swappable.** Internally Conductor uses **dyno-queues**, but the **QueueDAO** abstraction lets you replace them with other providers—**SQS-like systems**, AMQP, etc. (there are community and Orkes guides for SQS integration). ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/index.html "Architecture Overview - Conductor Documentation"))

**Shards & internal queues → horizontal scale.**  
Conductor allocates **queues per task type** and also maintains an internal **decider queue** (used by the Sweeper/decider). In a multi-node cluster, **each server instance gets its own shard of every queue**—for example, with two server instances and task types `HTTP` and `LAMBDA`, you’ll see per-instance suffixed queues (e.g., `…HTTP.c`, `…HTTP.d`, `…LAMBDA.c`, `…_deciderQueue.c`, `…_deciderQueue.d`). Adding more server instances **adds shards**, enabling horizontal scaling of scheduling and decider work. ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/technicaldetails.html "Technical Details - Conductor Documentation"))

**Redis/cluster variants.** For Redis-style deployments you can select **dynomite, redis_cluster, sentinel, or standalone** via config (`conductor.db.type` / `conductor.queue.type`) and supply hosts/ACLs. Dev mode can run on an **in-memory Redis mock**. ([Conductor OSS](https://conductor-oss.github.io/conductor/documentation/advanced/redis.html "Redis - Conductor Documentation"))

**Postgres tuning levers (if you go single-back-end).** With Postgres you can:

- Switch on Postgres **indexing** (`conductor.indexing.enabled=true; conductor.indexing.type=postgres`),
    
- Reduce index write load (index “only on status change”),
    
- Buffer **PollData** writes, and
    
- Optionally enable **LISTEN/NOTIFY-based queues** to cut polling chatter between nodes. ([Conductor OSS](https://conductor-oss.github.io/conductor/documentation/advanced/postgresql.html "PostgreSQL - Conductor Documentation"))
    

**Practical choose-your-own-adventure**

- Need **highest throughput** and familiar ELK search? → **Redis/Dynomite + Elasticsearch**. ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/index.html "Architecture Overview - Conductor Documentation"))
    
- Want **fewer dependencies** and moderate scale? → **PostgreSQL** for state, queues, and indexing (benchmark your flow first). ([Conductor OSS](https://conductor-oss.github.io/conductor/documentation/advanced/postgresql.html "PostgreSQL - Conductor Documentation"))
    
- Have an existing broker mandate? → Keep state in Redis/Postgres and **swap the queue provider** (e.g., SQS) via `QueueDAO`. ([Conductor OSS](https://conductor-oss.github.io/conductor/devguide/architecture/index.html "Architecture Overview - Conductor Documentation"))