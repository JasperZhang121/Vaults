### The worker life-cycle (one task type)

1. **Poll** a queue for available work 
2. **Ack** receipt so the server knows you took it 
3. **Execute** your business logic 
4. **Update** the task result as `COMPLETED`, `FAILED`, or keep it `IN_PROGRESS` (optionally with a next wake-up). 

Conductor exposes first-class REST endpoints for this loop, and all official SDKs (Java, Python, JS/TS, Go, C#, Clojure) wrap the same semantics. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))

---

### Poll

- **Single poll:**  
    `GET /tasks/poll/{taskType}?workerid=&domain=`  
    Returns one schedulable task for that type. `workerid` tags who polled; `domain` scopes routing (useful for blue/green, dev/local testing, or multi-tenant routing). ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))
    
- **Batch poll (for throughput):**  
    `GET /tasks/poll/batch/{taskType}?count=&timeout=&workerid=&domain`  
    This is **long-polling**: the call waits up to `timeout` unless at least one task is available sooner. Use it to reduce request churn and increase parallelism. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))
    

---

### Ack (why it matters)

After polling, the worker **acknowledges** the task. If the worker doesn’t ack, **Conductor re-queues** the task so another worker can pick it up—this is how the system self-heals when a poller crashes after fetching work. SDKs expose an `ack()` call; the Java client’s `TaskClient` documents an explicit ack operation. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))

---

### Update (reporting results & heartbeats)

Workers **POST** a `TaskResult` to update status and outputs:

```json
{
  "workflowInstanceId": "…",
  "taskId": "…",
  "status": "IN_PROGRESS",
  "outputData": { "partial": true },
  "reasonForIncompletion": "",
  "callbackAfterSeconds": 30
}
```

- **Statuses:** `IN_PROGRESS`, `FAILED`, `COMPLETED` (the OSS API schema); Orkes adds `FAILED_WITH_TERMINAL_ERROR` in its managed offering. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))
    
- **Heartbeats / deferrals:** Return `IN_PROGRESS` with **`callbackAfterSeconds`** to tell Conductor when to resurface the _same_ task instance for continued work (e.g., polling an external system until ready). ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))
    

---

### Minimal pseudo-loop (language-agnostic)

```text
while true:
  tasks = GET /tasks/poll/batch/{type}?count=N&timeout=T&workerid=me&domain=mydomain
  for t in tasks:
    ack(t.id)                              # SDK call
    try:
      out = doWork(t.inputData)
      POST /tasks { taskId: t.id, status: COMPLETED, outputData: out }
    catch (retryable e):
      POST /tasks { taskId: t.id, status: IN_PROGRESS, callbackAfterSeconds: 15 }
    catch (fatal e):
      POST /tasks { taskId: t.id, status: FAILED, reasonForIncompletion: e.message }
```

This pattern is identical across SDKs; the SDK just hides the HTTP details. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/clientsdks/index.html "Client SDKs - Conductor Documentation"))

---

### Operational notes & best practices

- **Idempotency is non-negotiable.** A worker may see the same task again (timeouts, crashes, retries). Make side-effects safe to repeat (e.g., by using idempotency keys or “check-then-create” semantics). Even Netflix’s public write-up calls out idempotent, stateless workers; Orkes’ guides reiterate this. ([techblog.netflix.com](https://techblog.netflix.com/2016/12/netflix-conductor-microservices.html?utm_source=chatgpt.com "Netflix Conductor: A microservices orchestrator"))
    
- **Backpressure is built-in.** Because workers **pull** work, you can scale pollers up/down to match capacity; the long-poll model helps keep queues stable. ([techblog.netflix.com](https://techblog.netflix.com/2016/12/netflix-conductor-microservices.html?utm_source=chatgpt.com "Netflix Conductor: A microservices orchestrator"))
    
- **Domains for safe routing.** Use the `domain` query param to isolate canaries/locals from production queues (e.g., `T2` tasks to `mydomain`). ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/taskdomains.html "Task Domains - Conductor Documentation"))
    
- **Observe queues.** Conductor exposes queue metrics and “last poll time” so you can confirm workers are alive and keep an eye on backlog. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))
    

---

### Handy REST shapes (reference)

- **Poll (batch, long-poll):** `GET /tasks/poll/batch/{taskType}?count=10&timeout=10000&workerid=payments-1&domain=blue`
    
- **Update result:** `POST /tasks` with the `TaskResult` schema above. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html "Task API - Conductor Documentation"))