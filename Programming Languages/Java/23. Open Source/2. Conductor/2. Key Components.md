### Workflow

A **workflow** is a <mark style="background: #FFF3A3A6;">JSON definition (DSL)</mark> that declares the **steps**, their **inputs/outputs**, and **control-flow** (parallelism, branching, loops, and reuse via sub-workflows). Conductor reads this spec and schedules tasks in order, passing each step the data it needs an d collecting outputs for downstream steps. Typical fields: `name`, `version`, `tasks[]` (each with `type`, `name`, `taskReferenceName`, optional `inputParameters`, `optional`, `retry`, `timeout`, etc.). Control-flow operators include **FORK_JOIN**, **SUB_WORKFLOW**, and **DO_WHILE** for parallelism, composition, and looping. ([orkes.io](https://orkes.io/content/core-concepts?utm_source=chatgpt.com "Core Concepts | Orkes Conductor Documentation"))

Minimal sketch:

```json
{
  "name": "order_fulfillment",
  "version": 1,
  "tasks": [
    { "type": "SIMPLE", "name": "reserve_inventory", "taskReferenceName": "reserve" },
    { "type": "FORK_JOIN", "taskReferenceName": "parallel",
      "forkTasks": [
        [{ "type": "SIMPLE", "name": "charge_payment", "taskReferenceName": "pay" }],
        [{ "type": "SIMPLE", "name": "create_label", "taskReferenceName": "ship" }]
      ]
    },
    { "type": "JOIN", "taskReferenceName": "join" }
  ]
}
```

Tip: register `SIMPLE` task types before using them in workflows (task registry). ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/configuration/taskdef.html?utm_source=chatgpt.com "Task Definition - Conductor Documentation"))

---

### Task

A **task** is the smallest schedulable unit within a workflow. Kinds you’ll use often:

- **SIMPLE** (your custom business logic)
    
- **HTTP**, **EVENT**, **WAIT**, **KAFKA**, etc. (system/integration tasks)
    
- **SUB_WORKFLOW**, **FORK_JOIN**, **SWITCH**, **DO_WHILE** (control-flow)  
    Each task declares inputs and emits outputs that subsequent steps can consume. ([orkes.io](https://orkes.io/content/reference-docs/operators/fork-join?utm_source=chatgpt.com "Fork/Join | Orkes Conductor Documentation"))
    

---

### Worker

A **worker** is your code (any language) that implements a task type. Workers **poll** Conductor for available work, **ack** receipt, **execute**, and **update** the result (COMPLETED/FAILED/IN_PROGRESS with outputs). This poll-ack-update loop is the same across SDKs (Java, Python, JS, Go, C#, etc.). Write workers to be **idempotent** and run them continuously for throughput. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html?utm_source=chatgpt.com "Task API - Conductor Documentation"))

Pseudo-loop:

```
repeat:
  tasks = /tasks/poll/{taskType}?count=N
  for t in tasks:
    /tasks/{t.id}/ack
    result = doWork(t.inputData)
    POST /tasks  (status + outputData + logs)
```

API shape: “Polling, Ack and Update Task.” ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/api/task.html?utm_source=chatgpt.com "Task API - Conductor Documentation"))

---

### Queue

Conductor runs on a **worker–task-queue architecture**: **each task type has its own dedicated queue**. The server enqueues runnable tasks; your workers dequeue by polling their task-type queue. Operators can monitor queue sizes and pollers via UI/APIs. ([orkes.io](https://orkes.io/content/conductor-architecture?utm_source=chatgpt.com "Conductor Architecture and Worker Polling"))

Implementation notes:

- **Pluggable queuing**: Conductor’s architecture allows different queue providers. Historically, **dyno-queues** backed the default queues and Conductor also maintains internal “decider” queues; queue shards exist per server instance for scale. Newer Orkes deployments use **Orkes Queues** (Redis-based) under the hood. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/devguide/architecture/index.html?utm_source=chatgpt.com "Architecture Overview - Conductor Documentation"))
    
- **Event integrations**: For event-driven steps, the **EVENT** task can publish/consume via **internal queue, AMQP, Kafka, NATS/NATS Streaming, or AWS SQS**—useful when you want Conductor to interoperate with external brokers. ([conductor-oss.github.io](https://conductor-oss.github.io/conductor/documentation/configuration/workflowdef/systemtasks/event-task.html?utm_source=chatgpt.com "Event Task - Conductor Documentation"))
    

**Mental model:**  
_Workflow_ (the JSON plan) → _Tasks_ (the steps) → _Queues_ (one per task type) → _Workers_ (your code polling those queues). Once you internalize this loop, Conductor’s behavior—scheduling, retries, back-pressure, and observability—falls neatly into place. ([orkes.io](https://orkes.io/content/conductor-architecture?utm_source=chatgpt.com "Conductor Architecture and Worker Polling"))
