
Netty is a high-performance, asynchronous event-driven network application framework that simplifies the development of network applications such as protocol servers and clients.

### Channel

A `Channel` represents an <mark style="background: #FFB8EBA6;">open connection to an entity such as a hardware device, a file, a network socket</mark>, or a component that is capable of performing I/O operations such as read or write.

In Netty, a `Channel` provides:

- Asynchronous I/O operations (non-blocking)
    
- Pipeline support via `ChannelPipeline`
    
- Safe multithreaded access
    
- I/O lifecycle management
    

#### Key Interfaces & Classes

- `io.netty.channel.Channel`: The primary interface for all I/O operations.
    
- `AbstractChannel`: A skeletal implementation of `Channel`.
    
- `SocketChannel`: A common implementation for TCP socket connections.
    
- `DatagramChannel`: For UDP-based transport.
    
- `EmbeddedChannel`: A special channel for unit testing handlers.
    

#### Important Methods

```java
ChannelFuture write(Object msg);
ChannelFuture writeAndFlush(Object msg);
ChannelPipeline pipeline();
EventLoop eventLoop();
SocketAddress localAddress();
SocketAddress remoteAddress();
```

#### Channel Lifecycle

The channel lifecycle is typically:

1. **Unregistered** → 2. **Registered** → 3. **Active** → 4. **Inactive** → 5. **Unregistered**
    

|Stage|Description|
|---|---|
|Registered|Bound to an `EventLoop`, ready for I/O events|
|Active|Connected (for sockets) or ready to read/write|
|Inactive|Closed or not connected|
|Unregistered|Deregistered from EventLoop; typically after shutdown|


### ChannelPipeline & ChannelHandler

Netty uses a **pipeline** to handle I/O events and data transformations.

- `ChannelPipeline`: A sequence of `ChannelHandler`s.
    
- `ChannelInboundHandler`: Handles inbound events like read, active, etc.
    
- `ChannelOutboundHandler`: Handles outbound events like write, flush, etc.
    

Example:

```java
public class MyServerInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel ch) {
        ch.pipeline().addLast(new MyDecoder());
        ch.pipeline().addLast(new MyBusinessHandler());
        ch.pipeline().addLast(new MyEncoder());
    }
}
```


### ByteBuf

Netty uses its own buffer implementation called `ByteBuf`, which offers a more powerful and flexible interface than Java NIO's `ByteBuffer`.

#### Advantages over `java.nio.ByteBuffer`

- Read/Write indexes are separated
    
- No flipping (like `flip()` in `ByteBuffer`)
    
- Supports dynamic resizing
    
- Supports pooling (via `PooledByteBufAllocator`)
    
- Rich API (e.g., slice, duplicate, composite)
    

#### Key Fields

- `readerIndex`: Index for the next read
    
- `writerIndex`: Index for the next write
    
- `capacity`: Current size of the buffer
    
- `maxCapacity`: Maximum size the buffer can grow to
    

#### Lifecycle Example

```java
ByteBuf buf = Unpooled.buffer(256);  // Default capacity
buf.writeByte(0x01);
buf.writeInt(100);
int val = buf.readInt();             // Read in order
```

#### CompositeByteBuf

Allows multiple `ByteBuf` instances to be merged logically without copying data.

```java
CompositeByteBuf compBuf = Unpooled.compositeBuffer();
compBuf.addComponents(buf1, buf2);
compBuf.writeBytes(buf3);
```


### Memory Management

Netty offers two main allocators:

- `UnpooledByteBufAllocator`: Always allocates unpooled memory (non-reusable)
    
- `PooledByteBufAllocator`: Uses pooling to reduce GC pressure and improve performance
    

> Best practice: Use pooled buffers for high-performance server applications.


### Reference Counting

Netty uses **reference counting** to manage `ByteBuf` memory. Each `ByteBuf` has a reference count; when it reaches zero, the memory is released.

```java
ByteBuf buf = ...;
buf.retain();   // Increment reference count
buf.release();  // Decrement and possibly deallocate
```

Failure to release buffers can lead to memory leaks.
