### Two styles
1. **Annotated (@RestController)** — similar to Spring MVC but reactive types.
2. **Functional (RouterFunction/HandlerFunction)** — explicit routing, functional handlers.

### Annotated
```java
@RestController
@RequestMapping("/api")
public class UserController {
  private final UserService svc;
  public UserController(UserService svc){ this.svc = svc; }

  @GetMapping("/users/{id}")
  public Mono<User> get(@PathVariable String id){
    return svc.findById(id);
  }
}
```

### Functional
```java
@Configuration
public class Routes {
  @Bean
  RouterFunction<ServerResponse> routes(UserHandler h) {
    return RouterFunctions.route()
      .GET("/api/users/{id}", h::get)
      .POST("/api/users", h::create)
      .build();
  }
}

@Component
class UserHandler {
  private final UserService svc;
  UserHandler(UserService svc){ this.svc = svc; }

  public Mono<ServerResponse> get(ServerRequest req){
    return svc.findById(req.pathVariable("id"))
      .flatMap(user -> ServerResponse.ok().bodyValue(user))
      .switchIfEmpty(ServerResponse.notFound().build());
  }
}
```

### Exceptions & Filters
- Use `@ControllerAdvice` with `@ExceptionHandler` or `HandlerFilterFunction` for cross-cutting concerns.
- Prefer returning `Mono<ServerResponse>` with structured error objects.
