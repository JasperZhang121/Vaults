### Principles

- **Errors are signals**, not exceptions to be thrown around randomly. They travel the same pipe as data and completion.
    
- Prefer **explicit fallbacks** and **bounded, jittered retries** over blind “try again”.
    
- Be **type-aware**: only retry on **transient** failures (timeouts, 5xx), not on validation/business errors (4xx).
    
- Each attempt should be **time-boxed** with `timeout(...)`. Retries without timeouts can stall.
    

> Metaphor: your stream is a conveyor belt. Data boxes pass by (`onNext`), the belt either stops normally (`onComplete`) or hits the emergency stop (`onError`). You can add detours (`onErrorResume`) or try to nudge the belt again (`retryWhen`)—but only a few times, and not forever.

---

### The “onError” family

#### `onErrorReturn` / `onErrorResume` (fallbacks)

Use **`onErrorResume`** for type-specific fallbacks; **`onErrorReturn`** for a single default value.

```java
import reactor.core.publisher.Mono;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import java.time.Duration;

Mono<String> result =
    remoteCall()                                   // Mono<String>
      .timeout(Duration.ofSeconds(2))              // per-attempt timebox
      .onErrorResume(WebClientResponseException.NotFound.class, ex ->
          Mono.just("not-found-default"))          // type-specific fallback
      .onErrorResume(TimeoutException.class, ex ->
          Mono.just("cached-fallback"))            // another targeted fallback
      .onErrorResume(ex ->
          Mono.error(new IllegalStateException("unrecoverable", ex))); // rewrap
```

**Notes**

- The **first matching** `onErrorResume` wins.
    
- If you truly have a one-size fallback: `onErrorReturn("fallback")`.
    
- When the alternative path is async (cache/db), `onErrorResume` is the right tool.
    

---

### `onErrorMap` (normalize errors)

Map messy lower-level exceptions to domain-specific ones.

```java
remoteCall()
  .onErrorMap(ex -> ex instanceof TimeoutException
      ? new DownstreamUnavailable("timed out", ex)
      : ex);
```

---

### `onErrorContinue` (use sparingly)

Skip **only the failed element** and let the stream continue. Powerful but dangerous (can violate invariants).

```java
Flux<String> lines = ...;
lines.map(this::parse)
     .onErrorContinue((ex, badValue) -> log.warn("bad: {}", badValue, ex))
     .subscribe();
// Beware: upstream operators may not be prepared for skipped items.
```

Prefer **`materialize()` → treat errors as data** when you need “error per element” semantics:

```java
Flux<Signal<Integer>> processed =
  Flux.just("1","x","3")
      .map(Integer::parseInt)
      .materialize();              // turn onNext/onError/onComplete into Signals

processed
  .doOnNext(sig -> {
    if (sig.isOnError()) log.warn("bad element", sig.getThrowable());
  })
  .dematerialize()
  .onErrorResume(ex -> Flux.empty()) // swallow element-level errors only
  .subscribe();
```

---

### Timeouts

#### Basic timeout

```java
Flux<String> f = remoteStream().timeout(Duration.ofSeconds(3));
```

#### Timeout with fallback

```java
Mono<String> m =
  remoteMono().timeout(Duration.ofSeconds(2), Mono.just("from-cache"));
```

**Where to put `timeout` with retries?**  
Put **`timeout` before `retryWhen`** so **each attempt is time-boxed**:

```java
remoteCall()                           // Mono<T>
  .timeout(Duration.ofSeconds(2))      // attempt deadline
  .retryWhen(Retry.backoff(3, Duration.ofMillis(200)).jitter(0.3));
```

---

### Retries (bounded, selective, jittered)

```java
import reactor.util.retry.Retry;
import java.time.Duration;
import java.util.concurrent.TimeoutException;
import java.net.ConnectException;

remoteCall()
  .timeout(Duration.ofSeconds(2))
  .retryWhen(
    Retry.backoff(3, Duration.ofMillis(200))   // 3 retries, exponential backoff
         .maxBackoff(Duration.ofSeconds(2))
         .jitter(0.3)                          // spread the herd
         .filter(ex -> ex instanceof TimeoutException || ex instanceof ConnectException)
         .onRetryExhaustedThrow((spec, signal) ->
             new IllegalStateException("downstream unhealthy after retries", signal.failure()))
  )
  .subscribe();
```

#### Logging retry attempts

```java
.retryWhen(
  Retry.backoff(3, Duration.ofMillis(100))
       .doBeforeRetry(sig -> log.warn("retry #{} due to {}", sig.totalRetries()+1, sig.failure()))
)
```

#### `retryWhen` vs `repeatWhen`

- **`retryWhen`** re-subscribes on **error**.
    
- **`repeatWhen`** re-subscribes on **completion** (useful for polling).
    

---

### Composition patterns

#### 1) Fallback then surface cause (Mono)

```java
Mono<Order> order =
  fetchFromPrimary()
    .timeout(Duration.ofMillis(500))
    .onErrorResume(ex -> fetchFromCache())     // fallback path
    .switchIfEmpty(Mono.error(new NotFound("no order")));
```

#### 2) Guard a fan-out call (Flux)

```java
Flux<User> users = Flux.fromIterable(ids)
  .flatMap(id -> fetchUser(id)
      .timeout(Duration.ofMillis(300))
      .retryWhen(Retry.backoff(2, Duration.ofMillis(50)).filter(this::isTransient))
      .onErrorResume(ex -> Mono.empty()) // drop only failed element
  , /*concurrency*/ 64, /*prefetch*/ 32);
```

#### 3) Error demotion to value (circuit-friendly)

```java
Mono<Result<User>> guarded =
  fetchUser()
    .map(Result::ok)
    .onErrorResume(ex -> Mono.just(Result.err(ex))); // emit success OR error-as-value
```

Where `Result<T>` is a sealed type (success/failure). This prevents error explosions in fan-in.

---

## Debugging & diagnostics

### `checkpoint` (enrich stack traces)

```java
remoteCall()
  .checkpoint("user-service:fetch", true) // true = capture assembly traceback eagerly
  .subscribe();
```

#### Global hooks (use sparingly)

- `Hooks.onErrorDropped(err -> log.warn("dropped", err));`
    
- `Hooks.onOperatorDebug()` (heavy; prefer `checkpoint`).
    

#### Always clean up

```java
someFlux
  .doFinally(sig -> metrics.recordTermination(sig)) // runs on cancel/error/complete
  .subscribe();
```

---

### StepVerifier tests (deterministic behavior)

#### Verify timeout + retry attempts with virtual time

```java
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

AtomicInteger attempts = new AtomicInteger();

Mono<String> flaky =
  Mono.<String>fromCallable(() -> { attempts.incrementAndGet(); Thread.sleep(10); return "ok"; })
      .subscribeOn(Schedulers.boundedElastic())         // simulate slow
      .timeout(Duration.ofMillis(1))                    // force timeout error
      .retryWhen(Retry.backoff(2, Duration.ofMillis(5)).filter(ex -> ex instanceof TimeoutException));

StepVerifier.withVirtualTime(() -> flaky)
  .thenAwait(Duration.ofMillis(1 + 5 + 10))             // attempt + backoffs
  .expectError(TimeoutException.class)                  // ran out of retries
  .verify();

assert attempts.get() == 3; // 1 initial + 2 retries
```

#### Verify element-level fallback

```java
StepVerifier.create(
  Flux.just("1","x","3")
      .map(Integer::parseInt)
      .onErrorContinue((ex, v) -> {}) // skips "x"
)
.expectNext(1, 3)
.expectComplete()
.verify();
```

---

### Practical guardrails & anti-patterns

1. **Infinite retries** → cascading load, thundering herds.  
    _Fix:_ bound attempts; add **jitter**; consider a **circuit breaker** for persistent failures.
    
2. **Retrying non-idempotent operations** (e.g., charge card).  
    _Fix:_ ensure idempotency (request keys) or don’t retry.
    
3. **No per-attempt timeout** → single long hang.  
    _Fix:_ place `timeout` **before** `retryWhen`.
    
4. **Masking all errors with `onErrorResume(_ -> just(...))`** → hides real issues.  
    _Fix:_ be **selective**; log/trace unexpected failures; propagate when appropriate.
    
5. **`onErrorContinue` misuse** → broken invariants downstream.  
    _Fix:_ prefer `materialize`/`dematerialize` or drop/route errors explicitly.
    
6. **Blocking in error hooks** (e.g., writing logs synchronously).  
    _Fix:_ keep hooks lightweight; offload heavy logging/alerts elsewhere.
    
7. **Missing observability** on failure paths.  
    _Fix:_ emit counters/timers for retries, timeouts, fallbacks; tag with `outcome=success|fallback|error`.
    