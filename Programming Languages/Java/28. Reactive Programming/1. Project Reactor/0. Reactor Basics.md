### Types
- **Mono** — _a promise of at most one thing_ (0 or 1): success with a value, success without a value (empty), or error.
- **Flux** — _a conveyor belt of things_ (0..N): possibly finite or infinite, then either completes or errors.

> Think of **Mono** as “a single parcel delivery” and **Flux** as “a stream of parcels.” Both always end with either **delivered (onComplete)** or **delivery failed (onError)**.


### Creating

Cold publishers start fresh for each subscriber.

```java
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;
import java.time.Duration;

// Mono: 0..1
Mono<String> m = Mono.just("hi");                    // emits "hi", then complete
Mono<Integer> empty = Mono.empty();                  // completes immediately
Mono<Integer> error = Mono.error(new RuntimeException("boom")); // fails immediately

// Flux: 0..N
Flux<Integer> f = Flux.just(1,2,3);                  // 1,2,3 then complete
Flux<Integer> range = Flux.range(0, 10);             // 0..9
Flux<Long> ticks = Flux.interval(Duration.ofMillis(100)); // 0,1,2,... forever (never completes by itself)
```

#### `just` vs `fromSupplier` / `defer` / `fromCallable`
- `just(x)` captures **the value now**.
- `fromSupplier(s)` defers **value creation** until subscribe (no checked exceptions).
- `fromCallable(c)` defers and allows **checked exceptions** (converted to onError).
- `defer(factory)` **rebuilds** a publisher for each subscriber.
```java
Mono<Long> timeJust = Mono.just(System.currentTimeMillis());      // time captured now
Mono<Long> timeDeferred = Mono.fromSupplier(System::currentTimeMillis); // time captured on subscribe
Mono<Long> timePerSubscriber = Mono.defer(() -> Mono.just(System.currentTimeMillis()));
```
**Pitfall:** `Mono.just(expensive())` runs `expensive()` eagerly during assembly; use `fromSupplier(() -> expensive())` to defer.

### Transforming
Operators **don’t run** until someone subscribes.
```java
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;

Flux.just("a","b","c")
    .map(String::toUpperCase)               // A, B, C
    .flatMap(s -> Mono.just(s + "!"))       // A!, B!, C! (may interleave)
    .concatWithValues("DONE")               // … then "DONE"
    .subscribe(System.out::println);
```

#### `map` vs `flatMap` family
- `map(T -> R)` — synchronous one-to-one transform.
- `flatMap(T -> Publisher<R>)` — async one-to-many; **concurrent**, order may change.
- `concatMap` — like `flatMap` but **preserves order** (process one at a time).
- `switchMap` — **switch to latest**, cancel previous (great for “live search”).
```java
Flux<String> names = Flux.just("ann", "bob", "cy");
names.flatMap(n -> lookupId(n))            // lookup may run concurrently
     .subscribe();

// Ordered but potentially slower:
names.concatMap(n -> lookupId(n)).subscribe();

// Latest wins (cancels older requests)
names.switchMap(n -> querySuggestions(n)).subscribe();
```

> Rule of thumb: use `flatMap` when parallelism is fine, `concatMap` for ordering, `switchMap` for “only the latest matters.”

### Combining & merging streams

Different operators combine publishers with different **ordering** guarantees.

```java
import reactor.core.publisher.Flux;
import java.time.Duration;

Flux<Integer> a = Flux.range(1,3);
Flux<Integer> b = Flux.range(10,3);

// 1) Zip — pairwise lockstep (waits for one from each)
Flux.zip(a, b, (x,y) -> x + y)             // (1+10),(2+11),(3+12)
    .subscribe(System.out::println);       // 11, 13, 15

// 2) Merge — interleave by arrival time (order not guaranteed across sources)
Flux.merge(a.delayElements(Duration.ofMillis(50)), b)
    .subscribe(System.out::println);

// 3) Concat — strictly a then b (no overlap)
Flux.concat(a.delayElements(Duration.ofMillis(50)), b)
    .subscribe(System.out::println);

// 4) combineLatest — whenever any source emits, combine with the latest from others
Flux.combineLatest(
    values -> (int)values[0] + (int)values[1],
    Flux.range(1, 3).delayElements(Duration.ofMillis(40)),
    Flux.range(10, 3).delayElements(Duration.ofMillis(70))
).subscribe(System.out::println); // emits once each has produced at least one value
```

**Choosing:**
- **zip** for pairwise correlation,
- **merge** for concurrency/fan-in,
- **concat** for strict ordering,
- **combineLatest** for “react to any change using the latest of each.”

### Hot producers with Sinks (shared, live sources)

A **hot** source doesn’t replay past items to late subscribers (unless you use a replay sink). Sinks provide safe APIs for emitting.

```java
import reactor.core.publisher.Sinks;
import reactor.core.publisher.Flux;

// Multicast: broadcast to all current subscribers (late subscribers miss history)
Sinks.Many<String> bus = Sinks.many().multicast().onBackpressureBuffer();
Flux<String> stream = bus.asFlux();

bus.tryEmitNext("event-1");   // emits to current subscribers, if any
bus.tryEmitComplete();        // terminal signal

// Unicast: allow only one Subscriber (good for point-to-point)
Sinks.Many<String> uni = Sinks.many().unicast().onBackpressureBuffer();

// Replay: remember history (configurable size/time)
Sinks.Many<String> replay = Sinks.many().replay().limit(10);
```

**Overflow policy:** `multicast().onBackpressureBuffer()` buffers when slow subscribers lag. Consider **bounded buffers** or use **`onBackpressureLatest`** patterns downstream to avoid OOM.

> Concurrency note: `Sinks` are thread-safe for emission, but read their Javadoc for serialization rules. Prefer `emitNext(value, Sinks.EmitFailureHandler.FAIL_FAST)` in production and handle `EmissionException` explicitly.

### Resource safety & cleanup

Use **`using`** to tie resource lifecycle to subscription, and **`doFinally`** for cleanup regardless of termination type.

```java
import reactor.core.publisher.Flux;
import java.io.BufferedReader;
import java.io.FileReader;

Flux<String> lines = Flux.using(
    () -> new BufferedReader(new FileReader("data.txt")),  // acquire
    br -> Flux.fromStream(br.lines()),                     // use
    br -> { try { br.close(); } catch (Exception ignored) {} } // cleanup
);

lines.doFinally(sig -> System.out.println("terminated with: " + sig))
     .subscribe(System.out::println);
```

**Timeouts & retries** (for remote calls or slow sources):

```java
import reactor.util.retry.Retry;
import java.time.Duration;

Mono<String> remote = callRemote(); // returns Mono<String>
remote.timeout(Duration.ofSeconds(2))              // fail if too slow
      .retryWhen(Retry.backoff(3, Duration.ofMillis(200)).jitter(0.3)) // careful with retry storms
      .onErrorReturn("fallback")                   // last-resort fallback
      .subscribe(System.out::println);
```

### Scheduling (quick primer)

You’ll often see these when mixing with blocking code or CPU-heavy steps:

- `subscribeOn(scheduler)` — affects **where the source** begins work.
    
- `publishOn(scheduler)` — switch **downstream** operators to a new scheduler.
    

```java
import reactor.core.scheduler.Schedulers;

Flux.range(1, 5)
    .publishOn(Schedulers.parallel())  // downstream runs on parallel pool
    .map(i -> i * i)
    .subscribeOn(Schedulers.boundedElastic()) // source/upsream on elastic
    .subscribe();
```

> Keep it simple: avoid excessive hops. Use **`boundedElastic`** to isolate blocking calls; don’t block event-loop threads.

### Testing the basics (StepVerifier)

Deterministically assert what a sequence emits and when.

```java
import reactor.core.publisher.Flux;
import reactor.test.StepVerifier;
import java.time.Duration;

StepVerifier.create(Flux.just("A","B","C"))
    .expectNext("A","B","C")
    .expectComplete()
    .verify();

StepVerifier.withVirtualTime(() ->
    Flux.interval(Duration.ofSeconds(1)).take(3)  // 0,1,2 then complete
).thenAwait(Duration.ofSeconds(3))
 .expectNext(0L,1L,2L)
 .expectComplete()
 .verify();
```

### Practical pitfalls & guardrails

1. **Eager work in `just(...)`** — don’t run expensive/blocking code during assembly. Use `fromSupplier`/`fromCallable`/`defer`.
    
2. **Infinite `interval` without cancellation** — always `take(n)` or track disposables in long-running apps.
    
3. **Unbounded buffering** — if you see `onBackpressureBuffer()` without a cap, add one (and log drops) to prevent OOM.
    
4. **Blocking on event loops** — never call `block()` inside reactive pipelines or Netty event loops; isolate with `boundedElastic`.
    
5. **Wrong combiner** — mixing `merge` when you needed ordered results (→ use `concat`/`concatMap`) or pairwise correlation (→ use `zip`).
