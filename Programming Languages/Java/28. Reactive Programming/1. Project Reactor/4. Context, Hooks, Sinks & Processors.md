### Reactor Context — carrying metadata without ThreadLocal

**What it is:** a tiny, immutable **key/value bag** that travels _with the signals_ (not with threads). Each subscription has its own Context. You **write** it using `contextWrite(...)` and **read** it where you need it with `deferContextual(...)`.

> Metaphor: your data is a package on a conveyor belt; **Context** is the **shipping label** glued to the package. Even if the package jumps to a different conveyor (thread), the label stays with it.

#### Basics: write → read

```java
import reactor.core.publisher.Flux;

Flux.deferContextual(ctx -> {
  String user = ctx.getOrDefault("user","anonymous");
  return Flux.just("hello " + user);
})
.contextWrite(ctx -> ctx.put("user", "alice"))
.subscribe(System.out::println); // hello alice
```

**Why this works:** Context flows from **subscriber → upstream**. The `contextWrite` sits _below_ (closer to the subscriber than) the operator that needs it.

#### Placement rule (crucial)

`contextWrite(...)` affects **upstream of where it appears**.

```java
// ❌ Context appears too late; map() can't see it
Flux.just(1)
    .map(i -> i) // upstream
    .contextWrite(c -> c.put("k","v"))
    .subscribe();

// ✅ Place contextWrite "below" consumers that need it
Flux.just(1)
    .contextWrite(c -> c.put("k","v"))
    .map(i -> i) // sees k=v
    .subscribe();
```

#### Per-subscriber & immutable

Each subscription gets a **copy-on-write** Context; edits don’t leak across subscribers.

```java
var pipeline = Flux.deferContextual(c -> Flux.just(c.getOrDefault("reqId","-")));
pipeline.contextWrite(c -> c.put("reqId","A")).subscribe(System.out::println); // A
pipeline.contextWrite(c -> c.put("reqId","B")).subscribe(System.out::println); // B
```

#### Context crosses threads (no ThreadLocal needed)

```java
import reactor.core.scheduler.Schedulers;

Flux.deferContextual(c -> Flux.just("cid=" + c.get("cid")))
    .publishOn(Schedulers.parallel()) // thread-hop is fine
    .contextWrite(c -> c.put("cid","123"))
    .blockLast(); // prints: cid=123
```

#### Pattern: propagate correlation ID to logs (MDC bridge)

Do this at the **edge**, not inside every operator.

```java
import org.slf4j.MDC;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

Flux.deferContextual(ctx -> {
  String cid = ctx.getOrDefault("cid","n/a");
  return Flux.usingWhen(
      Mono.fromRunnable(() -> MDC.put("cid", cid)),             // acquire
      r -> Flux.range(1,3).doOnNext(i -> log.info("i={}", i)),  // use
      r -> Mono.fromRunnable(MDC::clear)                        // cleanup
);
})
.contextWrite(c -> c.put("cid","42"))
.blockLast();
```

#### Pattern: pass Context into `WebClient` headers

```java
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

WebClient client = WebClient.builder().baseUrl("https://api").build();

Mono<String> call =
  Mono.deferContextual(ctx -> client.get()
      .uri("/data")
      .headers(h -> h.add("X-Correlation-Id", ctx.getOrDefault("cid","-")))
      .retrieve()
      .bodyToMono(String.class))
  .contextWrite(c -> c.put("cid","abc-123"));
```

#### Test Context deterministically

```java
import reactor.test.StepVerifier;

StepVerifier.create(
  Flux.deferContextual(c -> Flux.just("u=" + c.get("user")))
      .contextWrite(c -> c.put("user","alice"))
)
.expectNext("u=alice")
.verifyComplete();
```

---

### Hooks (diagnostics) — make failures visible

- **`checkpoint("label", boolean forceStackCapture)`**: enrich stack traces with assembly info.
    
    ```java
    remoteCall()               // Mono<User>
      .map(this::parse)        // may throw
      .checkpoint("userService#parse", true)
      .subscribe();
    ```
    
    _Why:_ when an error bubbles, you’ll see “`userService#parse`” in the trace, pointing at the assembly site.
    
- **`log("category")`**: quick signal logging for a sequence.
    
    ```java
    Flux.range(1,3).log("demo").subscribe();
    ```
    
- **Global hooks (use sparingly)**
    
    - `Hooks.onErrorDropped(err -> log.warn("dropped", err));` — handle errors after cancel.
        
    - `Hooks.onNextDropped(o -> log.warn("dropped next {}", o));`
        
    - `Hooks.onOperatorDebug()` — heavy; prefer local `checkpoint`.
        
- **Always close the loop**  
    `doOnError`, `doFinally`, `doOnCancel` are cheap places to increment metrics, attach tags, and ensure cleanup.
    
    ```java
    someFlux
      .doOnError(ex -> metrics.count("failures"))
      .doFinally(sig -> metrics.count("terminated", sig.name()))
      .subscribe();
    ```
    

---

### Sinks — the modern way to push into Reactor

**Why Sinks?** They replace `Processor` with clearer semantics and explicit overflow handling.

#### Families & when to use

- **Multicast (broadcast live):**
    
    ```java
    Sinks.Many<String> bus = Sinks.many().multicast().onBackpressureBuffer();
    Flux<String> stream = bus.asFlux(); // multiple subscribers; late subscribers miss history
    ```
    
- **Replay (late subscribers catch up):**
    
    ```java
    Sinks.Many<String> replay = Sinks.many().replay().limit(2); // or .all(), .latest()
    Flux<String> feed = replay.asFlux();
    ```
    
- **Unicast (single subscriber):**
    
    ```java
    Sinks.Many<byte[]> uni = Sinks.many().unicast().onBackpressureBuffer();
    ```
    
- **One/Empty (one-shot handoff or just completion):**
    
    ```java
    Sinks.One<String> once = Sinks.one();
    Mono<String> result = once.asMono();
    once.tryEmitValue("done");
    ```
    

#### Multicast example with backpressure notes

```java
import reactor.core.publisher.Sinks;
import reactor.core.publisher.Flux;

Sinks.Many<String> bus = Sinks.many().multicast().onBackpressureBuffer(/*cap*/1024, d -> log.warn("overflow: {}", d));
// Two consumers
Flux<String> stream = bus.asFlux();
stream.subscribe(s -> System.out.println("A: " + s));
bus.tryEmitNext("event-1"); // goes to A
stream.subscribe(s -> System.out.println("B: " + s)); // joins late, misses event-1
bus.tryEmitNext("event-2"); // goes to A and B
```

**Guardrails:** set a **capacity** to avoid OOM; consider downstream shaping (`sample`, `limitRate`, `onBackpressureLatest`).

#### Replay example (stateful feed)

```java
Sinks.Many<String> replay = Sinks.many().replay().limit(2);
Flux<String> feed = replay.asFlux();

replay.tryEmitNext("v1");
replay.tryEmitNext("v2");
feed.subscribe(s -> System.out.println("S1: " + s)); // v1, v2
replay.tryEmitNext("v3");
feed.subscribe(s -> System.out.println("S2: " + s)); // v2, v3 (last 2)
```

#### Emission API: `tryEmit*` vs `emit*`

```java
var res = bus.tryEmitNext("x");
if (res.isFailure()) {
  // FAIL_ZERO_SUBSCRIBER, FAIL_OVERFLOW, FAIL_TERMINATED, FAIL_NON_SERIALIZED...
  log.warn("emit failed: {}", res);
}

// Auto-retry on non-serialized races:
bus.emitNext("y", (signalType, emitResult) ->
    emitResult == Sinks.EmitResult.FAIL_NON_SERIALIZED);
```

_Why:_ concurrent `emitNext` calls can be rejected; the handler above retries only when the failure was due to non-serialized access.

#### Bridge a callback-style API safely (unicast)

```java
Sinks.Many<String> uni = Sinks.many().unicast().onBackpressureBuffer(512);
Flux<String> flux = uni.asFlux();

startCallbackAPI(
  onMessage = msg -> {
    var r = uni.tryEmitNext(msg);
    if (r.isFailure()) { /* drop, log, or buffer elsewhere */ }
  },
  onClose = () -> uni.tryEmitComplete(),
  onError = err -> uni.tryEmitError(err)
);
```

#### StepVerifier (replay behavior)

```java
import reactor.test.StepVerifier;

Sinks.Many<Integer> replay = Sinks.many().replay().limit(2);
Flux<Integer> f = replay.asFlux();
replay.tryEmitNext(1);
replay.tryEmitNext(2);
replay.tryEmitNext(3);

StepVerifier.create(f.take(3))
  .expectNext(1,2,3)
  .verifyComplete();

StepVerifier.create(f.take(2)) // late subscriber: gets 2,3
  .expectNext(2,3)
  .verifyComplete();
```

---

### Pitfalls & guardrails

1. **Misplaced `contextWrite`** → upstream can’t see your keys.  
    _Fix:_ put `contextWrite` **below** the operators that will read it.
    
2. **Relying on ThreadLocal** across schedulers.  
    _Fix:_ store metadata in **Context**, bridge to MDC only at the edge.
    
3. **Unbounded sink buffers** under load → OOM.  
    _Fix:_ set capacity or use downstream shaping; consider `latest` semantics if appropriate.
    
4. **Ignoring `EmitResult`** from `tryEmit*` → silent data loss.  
    _Fix:_ check result or use `emit*` with a retry handler.
    
5. **Using `Processor`** instead of Sinks → subtle races & deprecations.  
    _Fix:_ always use **Sinks** families.
