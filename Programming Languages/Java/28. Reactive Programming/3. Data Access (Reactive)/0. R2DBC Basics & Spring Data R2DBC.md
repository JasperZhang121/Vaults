### Why R2DBC?
JDBC blocks threads on I/O. **R2DBC** provides a **non-blocking** SQL API. It shines when you need **high concurrency** with limited threads.

### Dependencies (Maven)
```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-r2dbc</artifactId>
</dependency>
<dependency>
  <groupId>io.r2dbc</groupId>
  <artifactId>r2dbc-postgresql</artifactId>
</dependency>
```

### Configuration
```yaml
spring:
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/app
    username: app
    password: secret
  sql:
    init:
      mode: always
```

### Entity & Repository
```java
@Table("users")
public record User(@Id Long id, String name) {}

public interface UserRepo extends ReactiveCrudRepository<User, Long> {
  Flux<User> findByNameContains(String q);
}
```

#### Service
```java
@Service
@RequiredArgsConstructor
public class UserService {
  private final UserRepo repo;
  public Mono<User> create(User u){ return repo.save(u); }
  public Mono<User> findById(Long id){ return repo.findById(id); }
  public Flux<User> search(String q){ return repo.findByNameContains(q); }
}
```

#### Transactions & Limitations
- Spring supports **reactive transactions** via `TransactionalOperator`. Avoid mixing with blocking JDBC in the same path.
- Some DB features (e.g., driver-specific) may lag behind JDBC.
