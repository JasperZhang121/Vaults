### Reactor Kafka (high-level)
**Dependencies (Maven)**
```xml
<dependency>
  <groupId>io.projectreactor.kafka</groupId>
  <artifactId>reactor-kafka</artifactId>
  <version>1.3.23</version>
</dependency>
```

**Consumer (exactly-once app-level via ack after success)**
```java
ReceiverOptions<String,String> ro = ReceiverOptions.<String,String>create(props)
    .subscription(Set.of("orders"))
    .addAssignListener(parts -> log.info("assigned: {}", parts));

KafkaReceiver<String,String> receiver = KafkaReceiver.create(ro);
receiver.receive() // Flux<ReceiverRecord<K,V>>
  .concatMap(rec -> process(rec.value())
      .then(Mono.fromRunnable(() -> rec.receiverOffset().acknowledge())))
  .retryWhen(Retry.backoff(3, Duration.ofMillis(200)).jitter(0.3))
  .subscribe();
```

**Producer**
```java
SenderOptions<String,String> so = SenderOptions.create(props);
KafkaSender<String,String> sender = KafkaSender.create(so);
Flux<SenderResult<Void>> results =
  sender.send(Flux.just(SenderRecord.create(
     new ProducerRecord<>("orders", "k1", "payload"), null)));
results.doOnNext(r -> log.info("sent: {}", r.correlationMetadata())).subscribe();
```

### Reactor RabbitMQ (AMQP)
```xml
<dependency>
  <groupId>io.projectreactor.rabbitmq</groupId>
  <artifactId>reactor-rabbitmq</artifactId>
  <version>1.5.6</version>
</dependency>
```
```java
Sender sender = RabbitFlux.createSender();
Receiver receiver = RabbitFlux.createReceiver();

sender.declareQueue(QueueSpecification.queue("q.orders")).block();
sender.send(Mono.just(new OutboundMessage("", "q.orders", "hello".getBytes()))).block();

receiver.consumeAutoAck("q.orders")
        .map(delivery -> new String(delivery.getBody()))
        .flatMap(this::process)
        .subscribe();
```

### Backpressure tips
- Prefer **`concatMap`** for at‑least‑once with ordering per partition/queue.
- Control **`prefetch`** to bound memory and in-flight messages.
- Use **DLQs** and **retry topics** instead of unbounded `retry` in hot paths.
