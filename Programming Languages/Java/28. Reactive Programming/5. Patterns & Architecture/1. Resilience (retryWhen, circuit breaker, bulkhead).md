### Retry: do it deliberately
Use jittered backoff and abort on non‑retryable errors.
```java
import reactor.util.retry.Retry;

Mono<String> call = remoteCall();
call.retryWhen(Retry.backoff(3, Duration.ofMillis(100))
                   .maxBackoff(Duration.ofSeconds(2))
                   .jitter(0.3)
                   .filter(ex -> ex instanceof TimeoutException || ex instanceof ConnectException))
    .subscribe();
```

### Circuit Breaker (Resilience4j)
```java
import io.github.resilience4j.circuitbreaker.*;
import io.github.resilience4j.reactor.circuitbreaker.operator.CircuitBreakerOperator;

CircuitBreakerConfig cbCfg = CircuitBreakerConfig.custom()
  .failureRateThreshold(50f)
  .slidingWindowType(SlidingWindowType.COUNT_BASED)
  .slidingWindowSize(50)
  .waitDurationInOpenState(Duration.ofSeconds(10))
  .permittedNumberOfCallsInHalfOpenState(5)
  .build();
CircuitBreaker cb = CircuitBreaker.of("downstream", cbCfg);

Mono<String> guarded = remoteCall()
  .transformDeferred(CircuitBreakerOperator.of(cb))
  .onErrorResume(CallNotPermittedException.class, e -> Mono.just("short-circuit"));
```

### Bulkhead (semaphore-based)
```java
import io.github.resilience4j.bulkhead.*;
import io.github.resilience4j.reactor.bulkhead.operator.BulkheadOperator;

BulkheadConfig bhCfg = BulkheadConfig.custom()
    .maxConcurrentCalls(64)
    .maxWaitDuration(Duration.ofMillis(10))
    .build();
Bulkhead bh = Bulkhead.of("downstream", bhCfg);

Flux<Data> pipeline = source
  .transformDeferred(BulkheadOperator.of(bh))
  .flatMap(this::handle);
```

### Composition order
Prefer: **RateLimiter → Bulkhead → CircuitBreaker → Retry** → Business logic. Add **timeout** near source.
