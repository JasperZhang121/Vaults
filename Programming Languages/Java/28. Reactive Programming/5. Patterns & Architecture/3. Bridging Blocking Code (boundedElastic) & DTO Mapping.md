### When you must call blocking APIs
Wrap at the **edges** and isolate using Reactor’s `boundedElastic` scheduler.

```java
Mono<User> findUserBlocking(String id) {
  return Mono.fromCallable(() -> jdbcTemplate.queryForObject(SQL, rowMapper, id))
             .subscribeOn(Schedulers.boundedElastic()); // isolate
}
```

### Aggregation example
```java
Mono<UserProfile> profile(String id) {
  Mono<User> u = findUserBlocking(id);
  Mono<List<Order>> orders = Mono.fromCallable(() -> orderDao.findByUser(id))
                                 .subscribeOn(Schedulers.boundedElastic());

  return Mono.zip(u, orders).map(tuple -> toProfile(tuple.getT1(), tuple.getT2()));
}
```

### DTO Mapping without blocking
- Use **pure functions** in `map`/`flatMap`.
- For heavy CPU mapping (JSON → DTO), consider `parallel()` carefully:
```java
Flux<JsonNode> json = ...;
json.parallel()
    .runOn(Schedulers.parallel())
    .map(this::toDto)
    .sequential();
```

### MapStruct example (compile-time mapper)
```java
@Mapper(componentModel = "spring")
public interface UserMapper {
  UserDto toDto(User user);
}
```

### Rules of thumb
- Never call `block()` on event loops.
- Keep blocking islands **short** and **bounded**; monitor with **BlockHound**.
