### Migration strategy (incremental)
1. **Strangle** via new reactive endpoints (`/v2/**`) while legacy stays alive.
2. Start with **read-only** paths (GET/stream) using WebFlux + R2DBC or reactive Mongo.
3. Introduce **WebClient** to call legacy services (non-blocking client to blocking servers).
4. Replace JDBC hotspots with **R2DBC** where concurrency issues are most severe.
5. Move shared domain logic to **pure functions** reusable from both stacks.
6. Roll out **observability** (metrics, tracing) to compare SLOs across stacks.

### Coexistence in one app
Use **Spring MVC + WebFlux** in same Boot app (two runtimes). Keep **separate controllers** and don’t mix reactive types in MVC handlers.

### JDBC to R2DBC pitfalls
- Connection handling & transactions differ; use **`TransactionalOperator`** or repositories.
- Unsupported JDBC features—check driver maturity.
- Pagination: switch to **keyset** for high-throughput streams.

### Example: side-by-side
```java
// legacy
@GetMapping("/v1/users/{id}")
public User v1(@PathVariable Long id){ return userService.find(id); }

// new
@GetMapping("/v2/users/{id}")
public Mono<User> v2(@PathVariable Long id){ return reactiveUserService.find(id); }
```
