### Loom (virtual threads)
- **Pros**: Imperative style, easier debugging, reuses JDBC/Servlet stacks, cheap threads (~KB stacks).
- **Cons**: Still blocking I/O semantics; needs scheduler & backpressure discipline at app level; libraries must be **Loom-aware** to avoid pinning (synchronized, native locks).

### Reactive (event loops)
- **Pros**: Backpressure protocol, fewer threads, excellent for high fan-out I/O.
- **Cons**: Steeper learning curve, stack traces harder (but `checkpoint` helps), mixing blocking is tricky.

### When to pick what
- **CRUD apps with moderate load** → Loom can be simpler and sufficient.
- **High concurrency gateways/stream processing** → Reactive shines.
- **Hybrid**: run Loom for blocking libraries, Reactive for gateways; or separate services.

### Example: keeping code similar with Loom
```java
// Loom style (Servlet/JDBC)
try (var conn = ds.getConnection();
     var ps = conn.prepareStatement(SQL)) {
  // imperative code; concurrency handled by many virtual threads
}
```
