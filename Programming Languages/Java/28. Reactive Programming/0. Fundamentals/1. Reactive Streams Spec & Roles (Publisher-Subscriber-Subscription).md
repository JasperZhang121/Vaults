### The Three Roles
- **Publisher**: Produces data and terminal signals.
- **Subscriber**: Receives data and terminal signals.
- **Subscription**: The control plane created when `subscribe()` happens; enables **request(n)** / **cancel()**.

#### The Protocol (simplified)
1. `Publisher.subscribe(Subscriber)` â†’ creates a `Subscription` and calls `onSubscribe(subscription)`.
2. `Subscriber` calls `subscription.request(n)` to signal demand.
3. `Publisher` may then deliver up to `n` `onNext` signals.
4. Terminal: `onError(t)` or `onComplete()` (exactly one).

#### Demand and Backpressure
- Demand is **accumulated**. Multiple `request(n)` add up.
- A `Publisher` may choose to emit **less** than requested (e.g., completes early) but **never more**.
- If a Publisher cannot honor backpressure (legacy sources), Reactor offers **backpressure operators** (buffer, drop, latest).

#### Reference Implementation in Reactor
Reactor types implement the Reactive Streams contracts:
- `Flux<T>` implements `Publisher<T>`
- `Mono<T>` implements `Publisher<T>`

#### Manual Subscriber Example
```java
import org.reactivestreams.Subscription;
import reactor.core.publisher.Flux;

public class ManualSubscriber {
  public static void main(String[] args) {
    Flux.range(1, 5).subscribe(new org.reactivestreams.Subscriber<>() {
      private Subscription s;
      public void onSubscribe(Subscription s) {
        this.s = s;
        s.request(2); // pull 2 items
      }
      public void onNext(Integer i) {
        System.out.println("got: " + i);
        if (i == 2) s.request(3); // request 3 more
      }
      public void onError(Throwable t) { t.printStackTrace(); }
      public void onComplete() { System.out.println("done"); }
    });
  }
}
```
