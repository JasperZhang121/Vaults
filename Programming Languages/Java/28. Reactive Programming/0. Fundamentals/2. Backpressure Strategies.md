### Why backpressure?
Without it, fast producers overwhelm slow consumers, causing **OOM**, **timeouts**, or **queue explosions**.

### Core strategies (Reactor)
- **Buffer**: Accumulate until downstream can keep up (risk: memory).  Operators: `onBackpressureBuffer(max, onOverflow, strategy)`
- **Drop**: Discard items when downstream is slow.  Operators: `onBackpressureDrop()`
- **Latest**: Keep only the most recent item.  Operators: `onBackpressureLatest()`
- **Rate-limit**: Ask upstream to slow down.  Operators: `limitRate(prefetch)`, `sample(Duration)`, `throttleLast`, `throttleFirst`

### Example: protect downstream with buffer + eviction
```java
import reactor.core.publisher.Flux;
import java.time.Duration;

public class BackpressureBuffer {
  public static void main(String[] args) {
    Flux.interval(Duration.ofMillis(10)) // fast source
        .onBackpressureBuffer(1000, d -> System.out.println("dropped: " + d))
        .sample(Duration.ofMillis(100))  // reduce rate
        .subscribe(System.out::println);

    try { Thread.sleep(2000); } catch (InterruptedException ignored) {}
  }
}
```

### Example: prefer latest (UI telemetry)
```java
Flux<Long> fast = Flux.interval(Duration.ofMillis(5)).onBackpressureLatest();
```

### `limitRate` and prefetch
```java
Flux.range(1, 10_000)
    .limitRate(256)       // request in batches to avoid bursty downstream
    .map(i -> i * 2)
    .subscribe();
```
