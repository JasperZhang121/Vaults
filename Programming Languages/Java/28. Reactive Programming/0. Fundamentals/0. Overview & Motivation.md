### What is Reactive Programming?
Reactive programming is a programming paradigm centered on **asynchronous, non-blocking data streams** and the **propagation of change**. In Java, it’s standardized by the **Reactive Streams** specification and implemented by libraries like **Project Reactor** and **RxJava**.

### Why use it?
- **Resource efficiency:** Non-blocking I/O uses fewer threads and keeps them busy only when work is available.
- **Backpressure-aware:** Consumers can signal capacity to producers to avoid overload.
- **Composability:** Streams of events (requests, messages, DB rows) can be transformed and combined declaratively.
- **Latency & throughput:** Reduced context switching and coordinated backpressure improve tail latency.

### Key vocabulary
- **Publisher / Flux / Mono:** Data sources that can emit 0..N (Flux) or 0..1 (Mono) items.
- **Subscriber:** Consumes, requests, and handles signals (onNext/onError/onComplete).
- **Subscription:** The control channel for demand (request(n)) and cancellation.
- **Backpressure:** The consumer’s ability to **control** the producer’s emission rate via demand.
- **Schedulers:** Strategy for where (which thread/pool) work runs (e.g., `boundedElastic`, `parallel`).

### When *not* to use it
- Workloads dominated by **CPU-bound** algorithms that do not block (consider Loom / structured concurrency or plain executors).
- Teams without operational maturity—reactive adds **new failure modes** and **debugging discipline**.
- Libraries you depend on are **blocking-only** and cannot be isolated off the main reactive path.

### Minimal mental model
Think “**pipelines of signals**”: items (onNext), terminal signals (onError/onComplete), with explicit **demand** from downstream to upstream and explicit **scheduling** (publishOn/subscribeOn).

### Hello, Reactor
```java
import reactor.core.publisher.Flux;

public class HelloReactor {
  public static void main(String[] args) {
    Flux.just("A", "B", "C")
        .map(String::toLowerCase)
        .filter(s -> !"b".equals(s))
        .subscribe(System.out::println);
  }
}
```
