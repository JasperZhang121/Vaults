### The Three Roles
- **Publisher** — *the faucet*: produces data items and terminal signals.
- **Subscriber** — *the cup*: consumes items and decides how much it can drink.
- **Subscription** — *the valve handle*: created on `subscribe()`, lets the cup **request(n)** more water or **cancel()** to stop.

### The Protocol
1. `Publisher.subscribe(Subscriber)` → creates a **Subscription** and calls `onSubscribe(subscription)` exactly once.
2. The **Subscriber** must call `subscription.request(n)` with **n > 0** to open the valve.
3. The **Publisher** may then deliver **up to n** `onNext` signals (never more), followed by more `request()`s as desired.
4. The Publisher sends **exactly one** terminal signal: `onError(t)` or `onComplete()` and **never emits** anything after that.
5. Signals are **serialized** (no concurrent `onNext` calls to the same subscriber).

> **Metaphor**: `request(n)` puts **n tokens** into a mailbox; each `onNext` consumes one token. The Publisher is not allowed to spend tokens it doesn’t have.


### Demand and Backpressure (what really happens)
- **Demand is accumulated:** multiple `request(n)` calls add up (`1 + 1 + 3 = 5`).
- **Unbounded demand:** `request(Long.MAX_VALUE)` effectively says “send as fast as you can.”
- **Publisher may emit fewer** than requested (e.g., data ended early) but **never more**.
- **Legacy / non-backpressured sources**: use Reactor’s operators to shape overflow:
- `onBackpressureBuffer(capacity, onOverflow, strategy)`
- `onBackpressureDrop()`, `onBackpressureLatest()`
- `limitRate(prefetch)`, `sample(Duration)`, `throttle*`

### Reference Types in Reactor
- `Flux<T>` implements `Publisher<T>` for **0..N** elements.
- `Mono<T>` implements `Publisher<T>` for **0..1** element.
- `BaseSubscriber<T>` is a convenience base class for building custom Subscribers with hooks.

### Minimal Manual Subscriber (step-wise pull)
```java
import org.reactivestreams.Subscription;
import reactor.core.publisher.Flux;

/** Demonstrates step-wise demand: first 2, then 3 more. */
public class ManualSubscriber {
  public static void main(String[] args) {
    Flux.range(1, 5).subscribe(new org.reactivestreams.Subscriber<Integer>() {
      private Subscription s;
      @Override public void onSubscribe(Subscription s) {
        this.s = s;
        s.request(2); // open valve for 2 items
      }
      @Override public void onNext(Integer i) {
        System.out.println("got: " + i);
        if (i == 2) s.request(3); // ask for the remaining 3
      }
      @Override public void onError(Throwable t) { t.printStackTrace(); }
      @Override public void onComplete() { System.out.println("done"); }
    });
  }
}
```

**Why this works:** the Publisher is allowed to send at most the total requested amount (2, then +3) and must then wait for more demand.

### Idiomatic Control with `BaseSubscriber`


```java
import reactor.core.publisher.Flux;
import reactor.core.publisher.BaseSubscriber;
import org.reactivestreams.Subscription;

public class BaseSubDemo {
  public static void main(String[] args) {
    Flux<Integer> source = Flux.range(1, 10);

    source.subscribe(new BaseSubscriber<Integer>() {
      @Override protected void hookOnSubscribe(Subscription s) {
        System.out.println("subscribed");
        request(1); // start with 1 item
      }
      @Override protected void hookOnNext(Integer value) {
        System.out.println("value = " + value);
        if (value < 5) {
          request(1); // pull one-by-one until 5
        } else {
          cancel();   // demonstrate cancellation
          System.out.println("cancelled after 5");
        }
      }
    });
  }
}
```

**Explanation:** `BaseSubscriber` exposes lifecycle hooks (`hookOnSubscribe`, `hookOnNext`, etc.) so you can implement custom **pull strategies** (size-1, bursts, adaptive).

### Unbounded vs Bounded Demand (trade-offs)

```java
Flux<String> fast = Flux.just("A","B","C");

// Unbounded: simplest, highest throughput, but push can outrun downstream CPU if later stages are expensive
fast.subscribe(new BaseSubscriber<>() {
  @Override protected void hookOnSubscribe(org.reactivestreams.Subscription s) { request(Long.MAX_VALUE); }
});

// Bounded: safer when later operators are costly
fast.limitRate(64).subscribe(System.out::println);
```

- **Unbounded** is fine for *known-small* or cheap streams.
- Prefer **bounded** + shaping (`limitRate`, buffering windows) when doing heavy mapping, I/O, or fan-in.

### Building Your Own Publisher Safely

Use `Flux.generate` (synchronous pull, per-request) or `Flux.create` (asynchronous). With `generate`, **each `onNext` corresponds to exactly one requested item**, making it naturally backpressure-aware.

```java
import reactor.core.publisher.Flux;
import reactor.core.publisher.SynchronousSink;

Flux<Integer> custom = Flux.generate(() -> 0, (state, sink) -> {
  sink.next(state);
  if (state == 4) sink.complete(); // total 5 items (0..4)
  return state + 1;
});

custom.subscribe(new BaseSubscriber<>() {
  @Override protected void hookOnSubscribe(org.reactivestreams.Subscription s) { request(2); }
  @Override protected void hookOnNext(Object value) {
    System.out.println("custom: " + value);
    request(1); // pull one more each time
  }
});
```

**Why `generate` is safe:** it’s synchronous and tied to demand—no overflow is possible because the sink emits only after a request.
If you must use `Flux.create` (multi-thread / async), **declare overflow policy**:

```java
import reactor.core.publisher.FluxSink;

Flux<Integer> created = Flux.create(emitter -> {
  new Thread(() -> {
    for (int i = 0; i < 1_000; i++) emitter.next(i);
    emitter.complete();
  }).start();
}, FluxSink.OverflowStrategy.BUFFER); // or DROP/LATEST/ERROR
```

### Valid/Invalid `request(n)` Calls
- `request(1)`, `request(10)`, `request(Long.MAX_VALUE)`
- `request(0)` or `request(-1)` — **illegal** per spec; implementations typically signal `onError(new IllegalArgumentException())` or ignore further signals.


> **Tip:** If you see mysterious completion or errors, check for accidental `request(0)` in custom subscribers or libraries.

### Testing the Contract with StepVerifier
```java
import reactor.core.publisher.Flux;
import reactor.test.StepVerifier;
import java.time.Duration;

StepVerifier.create(Flux.range(1, 5), 0) // start with zero demand
  .thenRequest(2)
  .expectNext(1, 2)
  .thenRequest(3)
  .expectNext(3, 4, 5)
  .expectComplete()
  .verify();

// Time-based demand example
StepVerifier.withVirtualTime(() -> Flux.interval(Duration.ofSeconds(1)).take(3), 0)
  .thenAwait(Duration.ofSeconds(1))
  .thenRequest(1).expectNext(0L)
  .thenAwait(Duration.ofSeconds(1))
  .thenRequest(1).expectNext(1L)
  .thenAwait(Duration.ofSeconds(1))
  .thenRequest(1).expectNext(2L)
  .expectComplete()
  .verify();
```

  **Explanation:** StepVerifier lets you **script demand** and assert exact emission counts, mirroring how backpressure works at runtime.

### Common Pitfalls (and how to avoid them)
1. **Emitting more than requested** in custom Publishers → violates the spec, may cause backpressure errors. Use `generate` or gate `create` with demand/overflow strategies.
2. **Calling `block()` on event-loop threads** → deadlocks or stalls. Keep reactive end-to-end or isolate blocking on `boundedElastic`.
3. **Forgetting to request** in manual subscribers → you’ll see no `onNext` at all. Always request > 0.
4. **Concurrent signals** → don’t emit from multiple threads into the same sink without serialization; prefer `Sinks` APIs or external serialization.
5. **Unlimited buffering** → `onBackpressureBuffer()` without capacity may OOM; always cap and log overflow.

### Quick Recap
- The **Subscriber controls the pace** via `request(n)` (pull–push hybrid).
- The **Publisher respects demand** and serializes signals.
- Reactor gives you **safe defaults** (`Flux`, `Mono`, `generate`, `Sinks`) and **shaping tools** (buffer/drop/latest/limitRate).
- Use **StepVerifier** to test backpressure behavior deterministically.