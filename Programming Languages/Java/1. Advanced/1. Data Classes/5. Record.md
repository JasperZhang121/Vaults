In Java, when using types like `String` or `Integer`, these types are immutable classes, which have the following characteristics:

1. When defining a class, it is marked as `final`, meaning it cannot be subclassed.
2. Each field is marked as `final`, ensuring that once an instance is created, none of its fields can be modified.

Suppose we want to define a `Point` class with two variables, `x` and `y`, while making it an immutable class. We can do it like this:

```java
public final class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int x() {
        return this.x;
    }

    public int y() {
        return this.y;
    }
}
```

To ensure proper handling of immutable classes, we also need to correctly override the `equals()` and `hashCode()` methods so that they can be used in collection classes. We will cover the correct way to override `equals()` and `hashCode()` later. The purpose of demonstrating the `Point` immutable class here is to show that writing such code can be simple but somewhat tedious.

Records
Starting from Java 14, a new `Record` class is introduced. When defining a `Record` class, you use the `record` keyword. To rewrite the `Point` class as a `Record`, you can do it like this:

```java
// Record
public class Main {
    public static void main(String[] args) {
        Point p = new Point(123, 456);
        System.out.println(p.x());
        System.out.println(p.y());
        System.out.println(p);
    }
}

record Point(int x, int y) {}
```

Observe the definition of `Point`:

```java
record Point(int x, int y) {}
```

Rewriting the above definition as a regular class would be equivalent to the following code:

```java
final class Point extends Record {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int x() {
        return this.x;
    }

    public int y() {
        return this.y;
    }

    public String toString() {
        return String.format("Point[x=%s, y=%s]", x, y);
    }

    public boolean equals(Object o) {
        // ...
    }

    public int hashCode() {
        // ...
    }
}
```

In addition to marking the class as `final` and marking each field as `final`, the compiler also automatically generates constructor methods, methods with the same name as the fields, and overrides the `toString()`, `equals()`, and `hashCode()` methods for us.

In other words, using the `record` keyword, you can define an immutable class in just one line.

Similar to `enum`, we cannot directly derive from a `Record`. Instead, it is implemented by the compiler using the `record` keyword.

Constructor Methods
By default, the compiler automatically creates a constructor method for a `Record` in the order of the declared variables and assigns the values to the fields. Now, what if we want to perform checks on the parameters?

For example, if `x` and `y` of the `Point` class are not allowed to be negative, we need to add validation logic to the `Point` constructor:

```java
public record Point(int x, int y) {
    public Point {
        if (x < 0 || y < 0) {
            throw new IllegalArgumentException();
        }
    }
}
```

In this case, the method `public Point {...}` is called a Compact Constructor. Its purpose is to allow us to write validation logic, and the constructor ultimately generated by the compiler includes both our validation code and the assignment code:

```java
public final class Point extends Record {
    public Point(int x, int y) {
        // This is the Compact Constructor we wrote:
        if (x < 0 || y < 0) {
            throw new IllegalArgumentException();
        }
        // This is the assignment code generated by the compiler:
        this.x = x;
        this.y = y;
    }
    // ...
}
```

A `Record` like `Point` can still have static methods. One commonly used static method is `of()`, which is used to create instances:

```java
public record Point(int x, int y) {
    public static Point of() {
        return new Point(0, 0);
    }
    public static Point of(int x, int y) {
        return new Point(x, y);
    }
}
```

This allows us to write more concise code:

```java
var z = Point.of();
var p = Point.of(123, 456);
```

In summary:

- Starting from Java 14, the `record` keyword is introduced, making it very convenient to define Data Classes.
- Classes defined using `record` are <mark style="background: #FFF3A3A6;">immutable</mark>.
- You can write Compact Constructors to validate parameters.
- You can define static methods.