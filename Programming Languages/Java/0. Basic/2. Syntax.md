### Basic Data Types in Java

Basic data types are those types that the CPU can directly operate on. Java defines the following basic data types:

- **Integer Types**: `byte`, `short`, `int`, `long`
- **Floating-point Types**: `float`, `double`
- **Character Type**: `char`
- **Boolean Type**: `boolean`

#### Understanding the Differences Between These Data Types

To understand these differences, we need a basic understanding of computer memory structure.

- The smallest storage unit in computer memory is a byte. A byte is an 8-bit binary number, comprising 8 bits. Its binary representation ranges from 00000000 to 11111111, which translates to 0 to 255 in decimal, or 00 to ff in hexadecimal.

- Memory units are numbered starting from 0, known as memory addresses. Each memory unit can be seen as a room, with the memory address being the room number.

```ascii
      ┌───┐
  byte │   │
       └───┘
       ┌───┬───┐
 short │   │   │
       └───┴───┘
       ┌───┬───┬───┬───┐
   int │   │   │   │   │
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
  long │   │   │   │   │   │   │   │   │
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┬───┬───┐
 float │   │   │   │   │
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
double │   │   │   │   │   │   │   │   │
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┐
  char │   │   │
```


- A `byte` is exactly one byte, while `long` and `double` require eight bytes.

#### Integer Types

For integer types, Java <mark style="background: #FFB86CA6;">only defines signed integers</mark>. Therefore, the highest bit (bit) represents the sign (0 for positive, 1 for negative). The maximum range for various integer types is as follows:

- `byte`: -128 to 127
- `short`: -32768 to 32767
- `int`: -2147483648 to 2147483647
- `long`: -9223372036854775808 to 9223372036854775807

```java
public static void main(String[] args) {
    int i = 2147483647;
    int i2 = -2147483648;
    int i3 = 2_000_000_000; // Adding underscores for easier identification
    int i4 = 0xff0000; // Hexadecimal representation of 16711680
    int i5 = 0b1000000000; // Binary representation of 512

    long n1 = 9000000000000000000L; // Need to add 'L' at the end for long type
    long n2 = 900; // No 'L' added, here 900 is int, but int can be assigned to long
    int i6 = 900L; // Error: Cannot assign long type to int



	float f1 = 3.14f;
	float f2 = 3.14e38f; // Scientific notation for 3.14x10^38
	float f3 = 1.0; // Error: a number without 'f' at the end is of type double, cannot be assigned to float
	
	double d = 1.79e308;
	double d2 = -1.79e308;
	double d3 = 4.9e-324; // Scientific notation for 4.9x10^-324



	char a = 'A';
	char zh = '中';
	System.out.println(a);
	System.out.println(zh);
}
```


### Reference Types in Java

Besides the basic types mentioned earlier, all other types are reference types. One of the most commonly used reference types is the `String`:

```java
String s = "hello";
```

Reference type variables are similar to pointers in C language. They internally store an "address" that points to the location of some object in memory. 

#### Constants

When defining a variable, adding the `final` modifier makes this variable a constant:

```java
final double PI = 3.14; // PI is a constant
double r = 5.0;
double area = PI * r * r;
PI = 300; // compile error!
```

A constant, once initialized at the time of definition, cannot be reassigned. Attempting to do so will lead to a compilation error.

The purpose of constants is to avoid magic numbers by using meaningful variable names. For example, instead of writing 3.14 everywhere in the code, define a constant for it. If in the future we need to improve the calculation precision, we can simply modify the constant's definition, like changing it to 3.1416, instead of replacing 3.14 everywhere.

By convention, constant names are usually in all uppercase.

#### The `var` Keyword

Sometimes, the name of a type can be very long, making it cumbersome to write. For example:

```java
StringBuilder sb = new StringBuilder();
```

In such cases, to omit the variable type, you can use the `var` keyword:

```java
var sb = new StringBuilder();
```

The compiler automatically infers that the type of the variable `sb` is `StringBuilder`. To the compiler, the statement:

```java
var sb = new StringBuilder();
```

is automatically treated as:

```java
StringBuilder sb = new StringBuilder();
```

Therefore, using `var` to define a variable is merely a way to write less by omitting the variable type.

---
### Integer Arithmetic in Java

Integer values are not only precise, but integer operations are always exact, even division. This is because the division of two integers results in the integer part of the quotient:

```java
int x = 12345 / 67; // 184
```

For modulo operations, use `%`:

```java
int y = 12345 % 67; // The remainder of 12345 ÷ 67 is 17
```

**Important Note**: 
- Integer division in Java will throw a runtime error if the divisor is zero, but this will not cause a compile-time error.

- It's important to note that due to the limited range of integers, if the result of a calculation exceeds this range, it will lead to an overflow. Overflow does not result in an error but can produce unexpected results:

```java
public class Main {
    public static void main(String[] args) {
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    }
}
```

To understand the result of an integer overflow, let's consider adding the integers 2147483640 and 15 in binary:

```
  0111 1111 1111 1111 1111 1111 1111 1000 
+ 0000 0000 0000 0000 0000 0000 0000 1111 
  ----------------------------------------- 
  1000 0000 0000 0000 0000 0000 0000 0111
```

The highest bit (leftmost) in the result is 1, which in a signed integer indicates a negative number. Therefore, the sum becomes a negative number due to overflow.

#### Resolving Overflow Issues

To resolve the overflow problem demonstrated above, we can use the `long` data type instead of `int`. `long` has a much larger range for integer values, so the result will not overflow:

```java
long x = 2147483640;
long y = 15;
long sum = x + y;
System.out.println(sum); // 2147483655
```

---
### Bitwise Shift Operations in Java

In computers, integers are always represented in binary form. For example, the binary representation of the `int` type integer 7, using 4 bytes, is as follows:

```
00000000 00000000 00000000 00000111
```

We can perform shift operations on integers. Shifting the integer 7 to the left by 1 bit results in the integer 14, and shifting it left by two bits results in 28:

```java
int n = 7;        // 00000000 00000000 00000000 00000111 = 7
int a = n << 1;   // 00000000 00000000 00000000 00001110 = 14
int b = n << 2;   // 00000000 00000000 00000000 00011100 = 28
int c = n << 28;  // 01110000 00000000 00000000 00000000 = 1879048192
int d = n << 29;  // 11100000 00000000 00000000 00000000 = -536870912
```

When shifting left by 29 bits, the result becomes negative due to the highest bit turning into 1.

Similarly, right-shifting the integer 28 results in the following:

```java
int n = 7;        // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;   // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;   // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;   // 00000000 00000000 00000000 00000000 = 0
```

If we right-shift a negative number, the highest bit (1) remains unchanged, and the result is still a negative number:

```java
int n = -536870912;
int a = n >> 1;   // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;   // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28;  // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29;  // 11111111 11111111 11111111 11111111 = -1
```

There is also an unsigned right shift operation, `>>>`, which always fills the high-order bits with 0, regardless of the sign. Therefore, an unsigned right shift of a negative number will turn it into a positive number, as the highest bit changes from 1 to 0:

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```



